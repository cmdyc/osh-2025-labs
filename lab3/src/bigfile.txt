// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>
#include <semaphore.h>
#include <signal.h>
#include <ctype.h>
#include <sys/stat.h>
#include <errno.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 100
#define QUEUE_SIZE 40960
#define BUFFER_SIZE 4096

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
/*
// 线程池结构体
typedef struct thread_pool {
    pthread_t threads[THREAD_POOL_SIZE]; // 线程数组
    int queue[QUEUE_SIZE]; // 任务队列
    int head; // 任务队列的头部
    int tail; // 任务队列的尾部
    int clnt_socks[MAX_CONN]; // 存储客户端套接字的数组
    int clnt_cnt; // 连接的客户端数量
    sem_t sem_queue; // 任务队列的信号量
    pthread_mutex_t mutex_queue; // 互斥锁，用于保护任务队列的并发访问
    pthread_cond_t queue_not_full; // 条件变量，用于判断任务队列是否已满
    pthread_cond_t queue_not_empty; // 条件变量，用于判断任务队列是否为空
    int shutdown; // 表示线程池是否关闭
} thread_pool_t;

thread_pool_t pool;
*/

//  线程池结构体
typedef struct {
    pthread_t threads[THREAD_POOL_SIZE];  // 线程数组
    int task_queue[QUEUE_SIZE];           // 任务队列
    int queue_head;                       // 队列头指针
    int queue_tail;                       // 队列尾指针
    int shutdown;                         // 关闭标志，用于在主线程中退出循环
    pthread_mutex_t queue_mutex;          // 队列互斥锁
    pthread_cond_t queue_not_empty;       // 队列非空条件变量
    pthread_cond_t queue_not_full;        // 队列未满条件变量
} ThreadPool;

ThreadPool thread_pool;

int serv_sock;
int clnt_sock;

void print_perror(char *str) {
    perror(str);
    exit(1);
}

void divide_request(char *req, ssize_t req_len, char *method,char *url,char *version,char *host)
{
    ssize_t s1 = 0;
    while(s1 < req_len && req[s1] != ' ') {
        method[s1] = req[s1];
        s1++;
    }
    method[s1] = '\0';
    ssize_t s2 = s1 + 1;
    while(s2 < req_len && req[s2] != ' ') {
        url[s2 - s1 - 1] = req[s2];
        s2++;
    }
    url[s2 - s1 - 1] = '\0';
    ssize_t s3 = s2 + 1;
    while(s3 < req_len && req[s3] != '\n') {
        version[s3 - s2 - 1] = req[s3];
        s3++;
    }
    version[s3 - s2 - 1] = '\n';
    version[s3- s2] = '\0';
    ssize_t s4 = s3 + 1;
    while(s4 < req_len && req[s4] != '\n') {
        host[s4 - s3 - 1] = req[s4];
        s4++;
    }
    host[s4 - s3 - 1] = '\n';
    host[s4 - s3] = '\0';
}

// 解析 HTTP 请求
int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len, char *version)
{
    char* req = request;
    char *method = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *url = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *host = (char *)malloc(MAX_RECV_LEN * sizeof(char));
    //char *version = (char*) malloc(MAX_RECV_LEN * sizeof(char));

    divide_request(req, req_len, method, url, version, host);
    ssize_t url_len = strlen(url);
    ssize_t host_len = strlen(host);
    //ssize_t ver_len = strlen(version);
    // 如果请求的方法不为GET/请求的URL不以'/'开头/请求的版本号不为HTTP/开头或不以\r\n结尾，则返回错误
    if (strcmp(method,"GET") != 0 || url[0] != '/' ||
        (strncmp(version,"HTTP/1.0\r\n",10) != 0 && strncmp(version, "HTTP/1.1\r\n",10) != 0) ||
        strncmp(host, "Host: ", 6) != 0 || host[host_len-2] != '\r' || host[host_len-1] != '\n') {
        return -1;
    }
    memcpy(path,url,url_len+1);
    *path_len = url_len;
    return 0;
}

int get_content(char *path, long *file_size, FILE **file)
{
    char cur_dir[MAX_PATH_LEN];
    if(getcwd(cur_dir,sizeof(cur_dir)) == NULL) {
        perror("getcwd error!\n");
        return -1;
    }
    char *file_path = (char*) malloc(MAX_PATH_LEN * 2 * sizeof(char));
    if(file_path == NULL) {
        perror("malloc error!\n");
        return -1;
    }

    if(strlen(cur_dir) + strlen(path) + 2 > 2*MAX_PATH_LEN) {
        free(file_path);
        return -1;
    }
    snprintf(file_path, 2*MAX_PATH_LEN, "%s%s", cur_dir, path);

    struct stat path_stat;
    if(stat(file_path, &path_stat) == -1) {
        return -2;
    }
    if(S_ISDIR(path_stat.st_mode)) {
        fprintf(stderr, "%s is a directory!\n", file_path);
        return -1;
    }
    if(access(file_path, F_OK) == -1) {
        // 请求资源不存在时，返回-2
        perror("access error!\n");
        return -2;
    }

    // 判断访问路径是否跳出当前路径
    char *real_path = realpath(file_path, NULL);
    if(real_path == NULL) {
        perror("realpath error!\n");
        free(file_path);
        return -1;
    }
    // 检查绝对路径是否以当前目录为前缀
    if (strncmp(real_path, cur_dir, strlen(cur_dir)) != 0) {
        fprintf(stderr, "Error: Path traversal attempt detected\n");
        free(real_path);
        free(file_path);
        return -1;
    }
    
    *file = fopen(file_path, "r");
    if (*file == NULL) {
        perror("fopen error!\n");
        free(file_path);
        return -2;
    }

    fseek(*file, 0, SEEK_END);
    *file_size = ftell(*file);
    fseek(*file, 0, SEEK_SET);

    free(file_path);
    return 0;
}

int write_response(char *response, int ret, int ret_2, long file_size, int clnt_sock) 
{
    if(ret == -1 || ret_2 == -1) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_500);
    }
    else if(ret_2 == -2) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_404);
    }
    else if(ret == 0 && ret_2 == 0) {
        sprintf(response,
            "HTTP/1.0 %s\r\nContent-Length: %zd\r\n\r\n",
            HTTP_STATUS_200, file_size);
    }
    ssize_t response_len = strlen(response);

    // 写入响应，直到所有数据都被写入
    ssize_t write_len = 0;
    while(response_len > 0) {
        if((write_len = write(clnt_sock, response, response_len)) < 0) {
            perror("write error!\n");
            return -1;
        }
        response += write_len;
        response_len -= write_len;
    }
    return 0;
}

void handle_clnt(int clnt_sock)
{
    // 读取客户端发送来的数据，并解析
    char* req_buf = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char* version = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    // 构造要返回的数据
    // 注意，响应头部后需要有一个多余换行（\r\n\r\n），然后才是响应内容
    char* response = (char*) malloc(MAX_SEND_LEN * sizeof(char));
    // 根据 HTTP 请求的内容，解析资源路径和 Host 头
    char* path = (char*) malloc(MAX_PATH_LEN * sizeof(char));

    ssize_t req_len = 0;
    ssize_t n = 0;
    ssize_t max_recv_len = MAX_RECV_LEN;
    // 读取请求，直到遇到 "\r\n\r\n"
    while (1) {
        n = read(clnt_sock, req_buf + req_len, max_recv_len - req_len);
        if(n < 0) {
            if(errno == EINTR) continue;
            perror("read error!\n");
            goto end;
        }
        req_len += n;
        if(strlen(req_buf) >= 3 && strncmp(req_buf, "GET", 3) != 0) {
            write_response(response, -1, -1, 0, clnt_sock);
            goto end;
        }
        if (req_len >= 4 && strcmp(req_buf + req_len - 4, "\r\n\r\n") == 0) {
            break;
        }
        if(req_len >= max_recv_len) {
            max_recv_len *= 2;
            char *new_req_buf = (char *)realloc(req_buf, max_recv_len * sizeof(char));
            if(!new_req_buf) {
                perror("realloc error!\n");
                goto end;
            }
            req_buf = new_req_buf;
        }   
    }

    
    ssize_t path_len;
    int ret_1 = parse_request(req_buf, req_len, path, &path_len, version);
    long file_size;
    //char* content = NULL;
    FILE *file = NULL;
    int ret_2 = get_content(path, &file_size, &file);
    
    if(write_response(response, ret_1, ret_2, file_size, clnt_sock) == -1){
        goto end;
    }
    if(ret_2 == 0) {
        char buffer[BUFFER_SIZE];
        while (!feof(file)) {
            size_t n = fread(buffer, 1, BUFFER_SIZE, file);
            if (n < 0) {
                perror("read error!\n");
                break;
            }
            ssize_t write_len = 0;
            while (write_len < n) {
                ssize_t ret = write(clnt_sock, buffer + write_len, n - write_len);
                if (ret < 0) {
                    if(errno == EINTR) continue;
                    perror("write error!\n");
                    break;
                }
                write_len += ret;
            }
        }
        fclose(file);
    }
end:
    // 释放内存
    free(req_buf);
    free(path);
    free(response);
    free(version);
    //if(file != NULL)
      //  fclose(file);
    return;
}

//  工作线程函数
void* thread_worker(void* arg) {
    ThreadPool* pool = (ThreadPool*)arg;
    while (1) {
        pthread_mutex_lock(&pool->queue_mutex);
        
        // 等待队列非空
        while (pool->queue_head == pool->queue_tail && !pool->shutdown) {
            pthread_cond_wait(&pool->queue_not_empty, &pool->queue_mutex);
        }

        if (pool->shutdown) {
            pthread_mutex_unlock(&pool->queue_mutex);
            pthread_exit(NULL);
        }

        // 取出任务
        int clnt_sock = pool->task_queue[pool->queue_head];
        pool->queue_head = (pool->queue_head + 1) % QUEUE_SIZE;

        // 通知主线程队列有空位
        pthread_cond_signal(&pool->queue_not_full);
        pthread_mutex_unlock(&pool->queue_mutex);

        // 处理客户端请求
        handle_clnt(clnt_sock);
        close(clnt_sock);  // 在处理线程中关闭套接字
    }
    return NULL;
}

//  初始化线程池
void thread_pool_init(ThreadPool* pool) {
    pool->queue_head = 0;
    pool->queue_tail = 0;
    pool->shutdown = 0;
    pthread_mutex_init(&pool->queue_mutex, NULL);
    pthread_cond_init(&pool->queue_not_empty, NULL);
    pthread_cond_init(&pool->queue_not_full, NULL);

    // 创建工作线程
    for (int i = 0; i < THREAD_POOL_SIZE; i++) {
        pthread_create(&pool->threads[i], NULL, thread_worker, pool);
    }
}

//  向线程池添加任务
void thread_pool_add_task(ThreadPool* pool, int clnt_sock) {
    pthread_mutex_lock(&pool->queue_mutex);
    
    // 等待队列未满
    while ((pool->queue_tail + 1) % QUEUE_SIZE == pool->queue_head && !pool->shutdown) {
        pthread_cond_wait(&pool->queue_not_full, &pool->queue_mutex);
    }

    if (pool->shutdown) {
        pthread_mutex_unlock(&pool->queue_mutex);
        return;
    }

    // 添加任务到队列
    pool->task_queue[pool->queue_tail] = clnt_sock;
    pool->queue_tail = (pool->queue_tail + 1) % QUEUE_SIZE;

    // 通知工作线程有新任务
    pthread_cond_signal(&pool->queue_not_empty);
    pthread_mutex_unlock(&pool->queue_mutex);
}

int main(){
    // 创建套接字，参数说明：
    //   AF_INET: 使用 IPv4
    //   SOCK_STREAM: 面向连接的数据传输方式
    //   IPPROTO_TCP: 使用 TCP 协议
    if((serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
        print_perror("socket error!\n");

    // 将套接字和指定的 IP、端口绑定
    //   用 0 填充 serv_addr（它是一个 sockaddr_in 结构体）
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    //   设置 IPv4
    //   设置 IP 地址
    //   设置端口
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
    serv_addr.sin_port = htons(BIND_PORT);
    //   绑定
    if(bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1)
        print_perror("bind error!\n");

    // 使得 serv_sock 套接字进入监听状态，开始等待客户端发起请求
    if(listen(serv_sock, MAX_CONN) == -1)
        print_perror("listen error!\n");

    // 接收客户端请求，获得一个可以与客户端通信的新的生成的套接字 clnt_sock
    struct sockaddr_in clnt_addr;
    socklen_t clnt_addr_size = sizeof(clnt_addr);

    // 初始化线程池
    thread_pool_init(&thread_pool);

    while (1) // 一直循环
    {
        // 当没有客户端连接时，accept() 会阻塞程序执行，直到有客户端连接进来
        clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
        if(clnt_sock == -1) {
            perror("accept error!\n");
            continue;
        }
        // 处理客户端的请求
        thread_pool_add_task(&thread_pool, clnt_sock);
    }
    
    // 实际上这里的代码不可到达，可以在 while 循环中收到 SIGINT 信号时主动 break
    // 关闭套接字
    close(serv_sock);
    return 0;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>
#include <semaphore.h>
#include <signal.h>
#include <ctype.h>
#include <sys/stat.h>
#include <errno.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 100
#define QUEUE_SIZE 40960
#define BUFFER_SIZE 4096

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"

// 线程池结构体
typedef struct thread_pool {
    pthread_t threads[THREAD_POOL_SIZE]; // 线程数组
    int queue[QUEUE_SIZE]; // 任务队列
    int head; // 任务队列的头部
    int tail; // 任务队列的尾部
    int clnt_socks[MAX_CONN]; // 存储客户端套接字的数组
    int clnt_cnt; // 连接的客户端数量
    sem_t sem_queue; // 任务队列的信号量
    pthread_mutex_t mutex_queue; // 互斥锁，用于保护任务队列的并发访问
    pthread_cond_t queue_not_full; // 条件变量，用于判断任务队列是否已满
    pthread_cond_t queue_not_empty; // 条件变量，用于判断任务队列是否为空
    int shutdown; // 表示线程池是否关闭
} thread_pool_t;

thread_pool_t pool;

int serv_sock;
int clnt_sock;

void print_perror(char *str) {
    perror(str);
    exit(1);
}

void divide_request(char *req, ssize_t req_len, char *method,char *url,char *version,char *host)
{
    ssize_t s1 = 0;
    while(s1 < req_len && req[s1] != ' ') {
        method[s1] = req[s1];
        s1++;
    }
    method[s1] = '\0';
    ssize_t s2 = s1 + 1;
    while(s2 < req_len && req[s2] != ' ') {
        url[s2 - s1 - 1] = req[s2];
        s2++;
    }
    url[s2 - s1 - 1] = '\0';
    ssize_t s3 = s2 + 1;
    while(s3 < req_len && req[s3] != '\n') {
        version[s3 - s2 - 1] = req[s3];
        s3++;
    }
    version[s3 - s2 - 1] = '\n';
    version[s3- s2] = '\0';
    ssize_t s4 = s3 + 1;
    while(s4 < req_len && req[s4] != '\n') {
        host[s4 - s3 - 1] = req[s4];
        s4++;
    }
    host[s4 - s3 - 1] = '\n';
    host[s4 - s3] = '\0';
}

// 解析 HTTP 请求
int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len, char *version)
{
    char* req = request;
    char *method = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *url = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *host = (char *)malloc(MAX_RECV_LEN * sizeof(char));
    //char *version = (char*) malloc(MAX_RECV_LEN * sizeof(char));

    divide_request(req, req_len, method, url, version, host);
    ssize_t url_len = strlen(url);
    ssize_t host_len = strlen(host);
    //ssize_t ver_len = strlen(version);
    // 如果请求的方法不为GET/请求的URL不以'/'开头/请求的版本号不为HTTP/开头或不以\r\n结尾，则返回错误
    if (strcmp(method,"GET") != 0 || url[0] != '/' ||
        (strncmp(version,"HTTP/1.0\r\n",10) != 0 && strncmp(version, "HTTP/1.1\r\n",10) != 0) ||
        strncmp(host, "Host: ", 6) != 0 || host[host_len-2] != '\r' || host[host_len-1] != '\n') {
        return -1;
    }
    memcpy(path,url,url_len+1);
    *path_len = url_len;
    return 0;
}

int get_content(char *path, long *file_size, FILE **file)
{
    char cur_dir[MAX_PATH_LEN];
    if(getcwd(cur_dir,sizeof(cur_dir)) == NULL) {
        perror("getcwd error!\n");
        return -1;
    }
    char *file_path = (char*) malloc(MAX_PATH_LEN * 2 * sizeof(char));
    if(file_path == NULL) {
        perror("malloc error!\n");
        return -1;
    }

    if(strlen(cur_dir) + strlen(path) + 2 > 2*MAX_PATH_LEN) {
        free(file_path);
        return -1;
    }
    snprintf(file_path, 2*MAX_PATH_LEN, "%s%s", cur_dir, path);

    struct stat path_stat;
    if(stat(file_path, &path_stat) == -1) {
        return -2;
    }
    if(S_ISDIR(path_stat.st_mode)) {
        fprintf(stderr, "%s is a directory!\n", file_path);
        return -1;
    }
    if(access(file_path, F_OK) == -1) {
        // 请求资源不存在时，返回-2
        perror("access error!\n");
        return -2;
    }

    // 判断访问路径是否跳出当前路径
    char *real_path = realpath(file_path, NULL);
    if(real_path == NULL) {
        perror("realpath error!\n");
        free(file_path);
        return -1;
    }
    // 检查绝对路径是否以当前目录为前缀
    if (strncmp(real_path, cur_dir, strlen(cur_dir)) != 0) {
        fprintf(stderr, "Error: Path traversal attempt detected\n");
        free(real_path);
        free(file_path);
        return -1;
    }
    
    *file = fopen(file_path, "r");
    if (*file == NULL) {
        perror("fopen error!\n");
        free(file_path);
        return -2;
    }

    fseek(*file, 0, SEEK_END);
    *file_size = ftell(*file);
    fseek(*file, 0, SEEK_SET);

    free(file_path);
    return 0;
}

int write_response(char *response, int ret, int ret_2, long file_size, int clnt_sock) 
{
    if(ret == -1 || ret_2 == -1) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_500);
    }
    else if(ret_2 == -2) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_404);
    }
    else if(ret == 0 && ret_2 == 0) {
        sprintf(response,
            "HTTP/1.0 %s\r\nContent-Length: %zd\r\n\r\n",
            HTTP_STATUS_200, file_size);
    }
    ssize_t response_len = strlen(response);

    // 写入响应，直到所有数据都被写入
    ssize_t write_len = 0;
    while(response_len > 0) {
        if((write_len = write(clnt_sock, response, response_len)) < 0) {
            perror("write error!\n");
            return -1;
        }
        response += write_len;
        response_len -= write_len;
    }
    return 0;
}

void handle_clnt(int clnt_sock)
{
    // 读取客户端发送来的数据，并解析
    char* req_buf = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char* version = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    // 构造要返回的数据
    // 注意，响应头部后需要有一个多余换行（\r\n\r\n），然后才是响应内容
    char* response = (char*) malloc(MAX_SEND_LEN * sizeof(char));
    // 根据 HTTP 请求的内容，解析资源路径和 Host 头
    char* path = (char*) malloc(MAX_PATH_LEN * sizeof(char));

    ssize_t req_len = 0;
    ssize_t n = 0;
    ssize_t max_recv_len = MAX_RECV_LEN;
    // 读取请求，直到遇到 "\r\n\r\n"
    while (1) {
        n = read(clnt_sock, req_buf + req_len, max_recv_len - req_len);
        if(n < 0) {
            if(errno == EINTR) continue;
            perror("read error!\n");
            goto end;
        }
        req_len += n;
        if(strlen(req_buf) >= 3 && strncmp(req_buf, "GET", 3) != 0) {
            write_response(response, -1, -1, 0, clnt_sock);
            goto end;
        }
        if (req_len >= 4 && strcmp(req_buf + req_len - 4, "\r\n\r\n") == 0) {
            break;
        }
        if(req_len >= max_recv_len) {
            max_recv_len *= 2;
            char *new_req_buf = (char *)realloc(req_buf, max_recv_len * sizeof(char));
            if(!new_req_buf) {
                perror("realloc error!\n");
                goto end;
            }
            req_buf = new_req_buf;
        }   
    }

    ssize_t path_len;
    int ret_1 = parse_request(req_buf, req_len, path, &path_len, version);
    long file_size;
    //char* content = NULL;
    FILE *file = NULL;
    int ret_2 = get_content(path, &file_size, &file);
    
    if(write_response(response, ret_1, ret_2, file_size, clnt_sock) == -1){
        goto end;
    }
    if(ret_2 == 0) {
        char buffer[BUFFER_SIZE];
        while (!feof(file)) {
            size_t n = fread(buffer, 1, BUFFER_SIZE, file);
            if (n < 0) {
                perror("read error!\n");
                break;
            }
            ssize_t write_len = 0;
            while (write_len < n) {
                ssize_t ret = write(clnt_sock, buffer + write_len, n - write_len);
                if (ret < 0) {
                    if(errno == EINTR) continue;
                    perror("write error!\n");
                    break;
                }
                write_len += ret;
            }
        }
        fclose(file);
    }
end:
    // 释放内存
    free(req_buf);
    free(path);
    free(response);
    free(version);
    //if(file != NULL)
      //  fclose(file);
    return;
}

void *thread_func(void* arg)
{
    while (1)
    {
        // 等待信号量
        sem_wait(&pool.sem_queue);
        // 从任务队列中取出一个任务
        pthread_mutex_lock(&pool.mutex_queue);
        int clnt_sock = pool.queue[pool.head];
        pool.head = (pool.head + 1) % MAX_CONN;
        if((pool.tail + 1) % MAX_CONN != pool.head) {
            pthread_cond_signal(&pool.queue_not_full);
        }
        pthread_mutex_unlock(&pool.mutex_queue);
        if(pool.shutdown) {
            break;
        }
        // 处理任务
        handle_clnt(clnt_sock);
        close(clnt_sock);
    }
    return NULL;
}

int main(){
    // 创建套接字，参数说明：
    //   AF_INET: 使用 IPv4
    //   SOCK_STREAM: 面向连接的数据传输方式
    //   IPPROTO_TCP: 使用 TCP 协议
    if((serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
        print_perror("socket error!\n");

    // 将套接字和指定的 IP、端口绑定
    //   用 0 填充 serv_addr（它是一个 sockaddr_in 结构体）
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    //   设置 IPv4
    //   设置 IP 地址
    //   设置端口
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
    serv_addr.sin_port = htons(BIND_PORT);
    //   绑定
    if(bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1)
        print_perror("bind error!\n");

    // 使得 serv_sock 套接字进入监听状态，开始等待客户端发起请求
    if(listen(serv_sock, MAX_CONN) == -1)
        print_perror("listen error!\n");

    // 接收客户端请求，获得一个可以与客户端通信的新的生成的套接字 clnt_sock
    struct sockaddr_in clnt_addr;
    socklen_t clnt_addr_size = sizeof(clnt_addr);

    // 初始化线程池
    sem_init(&pool.sem_queue, 0, 0);
    pthread_mutex_init(&pool.mutex_queue, NULL);
    pthread_cond_init(&pool.queue_not_full, NULL);
    pthread_cond_init(&pool.queue_not_empty, NULL);
    pool.head = 0;
    pool.tail = 0;
    pool.clnt_cnt = 0;
    for(int i = 0;i < THREAD_POOL_SIZE;i++)
    {
        if(pthread_create(&pool.threads[i], NULL, thread_func, NULL) == -1)
            print_perror("pthread_create error!\n");
    }

    while (1) // 一直循环
    {
        // 当没有客户端连接时，accept() 会阻塞程序执行，直到有客户端连接进来
        clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
        if(clnt_sock == -1) {
            perror("accept error!\n");
            continue;
        }
        // 处理客户端的请求
        //handle_clnt(clnt_sock);
        pthread_mutex_lock(&pool.mutex_queue);
        // 线程池已满时等待
        while((pool.tail + 1) % MAX_CONN == pool.head) {
            pthread_cond_wait(&pool.queue_not_full, &pool.mutex_queue);
        }
        pool.queue[pool.tail] = clnt_sock;
        pool.clnt_socks[pool.clnt_cnt++] = clnt_sock;
        pool.tail = (pool.tail + 1) % MAX_CONN;
        if(pool.head != pool.tail) {
            pthread_cond_signal(&pool.queue_not_empty);
        }
        pthread_mutex_unlock(&pool.mutex_queue);
        sem_post(&pool.sem_queue);
    }
    
    // 实际上这里的代码不可到达，可以在 while 循环中收到 SIGINT 信号时主动 break
    // 关闭套接字
    close(serv_sock);
    return 0;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>
#include <semaphore.h>
#include <signal.h>
#include <ctype.h>
#include <sys/stat.h>
#include <errno.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 100
#define QUEUE_SIZE 40960
#define BUFFER_SIZE 4096

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"

// 线程池结构体
typedef struct thread_pool {
    pthread_t threads[THREAD_POOL_SIZE]; // 线程数组
    int queue[QUEUE_SIZE]; // 任务队列
    int head; // 任务队列的头部
    int tail; // 任务队列的尾部
    int clnt_socks[MAX_CONN]; // 存储客户端套接字的数组
    int clnt_cnt; // 连接的客户端数量
    sem_t sem_queue; // 任务队列的信号量
    pthread_mutex_t mutex_queue; // 互斥锁，用于保护任务队列的并发访问
    pthread_cond_t queue_not_full; // 条件变量，用于判断任务队列是否已满
    pthread_cond_t queue_not_empty; // 条件变量，用于判断任务队列是否为空
    int shutdown; // 表示线程池是否关闭
} thread_pool_t;

thread_pool_t pool;

int serv_sock;
int clnt_sock;

void print_perror(char *str) {
    perror(str);
    exit(1);
}

void divide_request(char *req, ssize_t req_len, char *method,char *url,char *version,char *host)
{
    ssize_t s1 = 0;
    while(s1 < req_len && req[s1] != ' ') {
        method[s1] = req[s1];
        s1++;
    }
    method[s1] = '\0';
    ssize_t s2 = s1 + 1;
    while(s2 < req_len && req[s2] != ' ') {
        url[s2 - s1 - 1] = req[s2];
        s2++;
    }
    url[s2 - s1 - 1] = '\0';
    ssize_t s3 = s2 + 1;
    while(s3 < req_len && req[s3] != '\n') {
        version[s3 - s2 - 1] = req[s3];
        s3++;
    }
    version[s3 - s2 - 1] = '\n';
    version[s3- s2] = '\0';
    ssize_t s4 = s3 + 1;
    while(s4 < req_len && req[s4] != '\n') {
        host[s4 - s3 - 1] = req[s4];
        s4++;
    }
    host[s4 - s3 - 1] = '\n';
    host[s4 - s3] = '\0';
}

// 解析 HTTP 请求
int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len, char *version)
{
    char* req = request;
    char *method = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *url = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *host = (char *)malloc(MAX_RECV_LEN * sizeof(char));
    //char *version = (char*) malloc(MAX_RECV_LEN * sizeof(char));

    divide_request(req, req_len, method, url, version, host);
    ssize_t url_len = strlen(url);
    ssize_t host_len = strlen(host);
    //ssize_t ver_len = strlen(version);
    // 如果请求的方法不为GET/请求的URL不以'/'开头/请求的版本号不为HTTP/开头或不以\r\n结尾，则返回错误
    if (strcmp(method,"GET") != 0 || url[0] != '/' ||
        (strncmp(version,"HTTP/1.0\r\n",10) != 0 && strncmp(version, "HTTP/1.1\r\n",10) != 0) ||
        strncmp(host, "Host: ", 6) != 0 || host[host_len-2] != '\r' || host[host_len-1] != '\n') {
        return -1;
    }
    memcpy(path,url,url_len+1);
    *path_len = url_len;
    return 0;
}

int get_content(char *path, long *file_size, FILE **file)
{
    char cur_dir[MAX_PATH_LEN];
    if(getcwd(cur_dir,sizeof(cur_dir)) == NULL) {
        perror("getcwd error!\n");
        return -1;
    }
    char *file_path = (char*) malloc(MAX_PATH_LEN * 2 * sizeof(char));
    if(file_path == NULL) {
        perror("malloc error!\n");
        return -1;
    }

    if(strlen(cur_dir) + strlen(path) + 2 > 2*MAX_PATH_LEN) {
        free(file_path);
        return -1;
    }
    snprintf(file_path, 2*MAX_PATH_LEN, "%s%s", cur_dir, path);

    struct stat path_stat;
    if(stat(file_path, &path_stat) == -1) {
        return -2;
    }
    if(S_ISDIR(path_stat.st_mode)) {
        fprintf(stderr, "%s is a directory!\n", file_path);
        return -1;
    }
    if(access(file_path, F_OK) == -1) {
        // 请求资源不存在时，返回-2
        perror("access error!\n");
        return -2;
    }

    // 判断访问路径是否跳出当前路径
    char *real_path = realpath(file_path, NULL);
    if(real_path == NULL) {
        perror("realpath error!\n");
        free(file_path);
        return -1;
    }
    // 检查绝对路径是否以当前目录为前缀
    if (strncmp(real_path, cur_dir, strlen(cur_dir)) != 0) {
        fprintf(stderr, "Error: Path traversal attempt detected\n");
        free(real_path);
        free(file_path);
        return -1;
    }
    
    *file = fopen(file_path, "r");
    if (*file == NULL) {
        perror("fopen error!\n");
        free(file_path);
        return -2;
    }

    fseek(*file, 0, SEEK_END);
    *file_size = ftell(*file);
    fseek(*file, 0, SEEK_SET);

    free(file_path);
    return 0;
}

int write_response(char *response, int ret, int ret_2, long file_size, int clnt_sock) 
{
    if(ret == -1 || ret_2 == -1) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_500);
    }
    else if(ret_2 == -2) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_404);
    }
    else if(ret == 0 && ret_2 == 0) {
        sprintf(response,
            "HTTP/1.0 %s\r\nContent-Length: %zd\r\n\r\n",
            HTTP_STATUS_200, file_size);
    }
    ssize_t response_len = strlen(response);

    // 写入响应，直到所有数据都被写入
    ssize_t write_len = 0;
    while(response_len > 0) {
        if((write_len = write(clnt_sock, response, response_len)) < 0) {
            perror("write error!\n");
            return -1;
        }
        response += write_len;
        response_len -= write_len;
    }
    return 0;
}

void handle_clnt(int clnt_sock)
{
    // 读取客户端发送来的数据，并解析
    char* req_buf = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char* version = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    // 构造要返回的数据
    // 注意，响应头部后需要有一个多余换行（\r\n\r\n），然后才是响应内容
    char* response = (char*) malloc(MAX_SEND_LEN * sizeof(char));
    // 根据 HTTP 请求的内容，解析资源路径和 Host 头
    char* path = (char*) malloc(MAX_PATH_LEN * sizeof(char));

    ssize_t req_len = 0;
    ssize_t n = 0;
    ssize_t max_recv_len = MAX_RECV_LEN;
    // 读取请求，直到遇到 "\r\n\r\n"
    while (1) {
        n = read(clnt_sock, req_buf + req_len, max_recv_len - req_len);
        if(n < 0) {
            if(errno == EINTR) continue;
            perror("read error!\n");
            goto end;
        }
        req_len += n;
        if(strlen(req_buf) >= 3 && strncmp(req_buf, "GET", 3) != 0) {
            write_response(response, -1, -1, 0, clnt_sock);
            goto end;
        }
        if (req_len >= 4 && strcmp(req_buf + req_len - 4, "\r\n\r\n") == 0) {
            break;
        }
        if(req_len >= max_recv_len) {
            max_recv_len *= 2;
            char *new_req_buf = (char *)realloc(req_buf, max_recv_len * sizeof(char));
            if(!new_req_buf) {
                perror("realloc error!\n");
                goto end;
            }
            req_buf = new_req_buf;
        }   
    }

    ssize_t path_len;
    int ret_1 = parse_request(req_buf, req_len, path, &path_len, version);
    long file_size;
    //char* content = NULL;
    FILE *file = NULL;
    int ret_2 = get_content(path, &file_size, &file);
    
    if(write_response(response, ret_1, ret_2, file_size, clnt_sock) == -1){
        goto end;
    }
    if(ret_2 == 0) {
        char buffer[BUFFER_SIZE];
        while (!feof(file)) {
            size_t n = fread(buffer, 1, BUFFER_SIZE, file);
            if (n < 0) {
                perror("read error!\n");
                break;
            }
            ssize_t write_len = 0;
            while (write_len < n) {
                ssize_t ret = write(clnt_sock, buffer + write_len, n - write_len);
                if (ret < 0) {
                    if(errno == EINTR) continue;
                    perror("write error!\n");
                    break;
                }
                write_len += ret;
            }
        }
        fclose(file);
    }
end:
    // 释放内存
    free(req_buf);
    free(path);
    free(response);
    free(version);
    //if(file != NULL)
      //  fclose(file);
    return;
}

void *thread_func(void* arg)
{
    while (1)
    {
        // 等待信号量
        sem_wait(&pool.sem_queue);
        // 从任务队列中取出一个任务
        pthread_mutex_lock(&pool.mutex_queue);
        int clnt_sock = pool.queue[pool.head];
        pool.head = (pool.head + 1) % MAX_CONN;
        if((pool.tail + 1) % MAX_CONN != pool.head) {
            pthread_cond_signal(&pool.queue_not_full);
        }
        pthread_mutex_unlock(&pool.mutex_queue);
        if(pool.shutdown) {
            break;
        }
        // 处理任务
        handle_clnt(clnt_sock);
        close(clnt_sock);
    }
    return NULL;
}

int main(){
    // 创建套接字，参数说明：
    //   AF_INET: 使用 IPv4
    //   SOCK_STREAM: 面向连接的数据传输方式
    //   IPPROTO_TCP: 使用 TCP 协议
    if((serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
        print_perror("socket error!\n");

    // 将套接字和指定的 IP、端口绑定
    //   用 0 填充 serv_addr（它是一个 sockaddr_in 结构体）
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    //   设置 IPv4
    //   设置 IP 地址
    //   设置端口
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
    serv_addr.sin_port = htons(BIND_PORT);
    //   绑定
    if(bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1)
        print_perror("bind error!\n");

    // 使得 serv_sock 套接字进入监听状态，开始等待客户端发起请求
    if(listen(serv_sock, MAX_CONN) == -1)
        print_perror("listen error!\n");

    // 接收客户端请求，获得一个可以与客户端通信的新的生成的套接字 clnt_sock
    struct sockaddr_in clnt_addr;
    socklen_t clnt_addr_size = sizeof(clnt_addr);

    // 初始化线程池
    sem_init(&pool.sem_queue, 0, 0);
    pthread_mutex_init(&pool.mutex_queue, NULL);
    pthread_cond_init(&pool.queue_not_full, NULL);
    pthread_cond_init(&pool.queue_not_empty, NULL);
    pool.head = 0;
    pool.tail = 0;
    pool.clnt_cnt = 0;
    for(int i = 0;i < THREAD_POOL_SIZE;i++)
    {
        if(pthread_create(&pool.threads[i], NULL, thread_func, NULL) == -1)
            print_perror("pthread_create error!\n");
    }

    while (1) // 一直循环
    {
        // 当没有客户端连接时，accept() 会阻塞程序执行，直到有客户端连接进来
        clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
        if(clnt_sock == -1) {
            perror("accept error!\n");
            continue;
        }
        // 处理客户端的请求
        //handle_clnt(clnt_sock);
        pthread_mutex_lock(&pool.mutex_queue);
        // 线程池已满时等待
        while((pool.tail + 1) % MAX_CONN == pool.head) {
            pthread_cond_wait(&pool.queue_not_full, &pool.mutex_queue);
        }
        pool.queue[pool.tail] = clnt_sock;
        pool.clnt_socks[pool.clnt_cnt++] = clnt_sock;
        pool.tail = (pool.tail + 1) % MAX_CONN;
        if(pool.head != pool.tail) {
            pthread_cond_signal(&pool.queue_not_empty);
        }
        pthread_mutex_unlock(&pool.mutex_queue);
        sem_post(&pool.sem_queue);
    }
    
    // 实际上这里的代码不可到达，可以在 while 循环中收到 SIGINT 信号时主动 break
    // 关闭套接字
    close(serv_sock);
    return 0;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>
#include <semaphore.h>
#include <signal.h>
#include <ctype.h>
#include <sys/stat.h>
#include <errno.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 100
#define QUEUE_SIZE 40960
#define BUFFER_SIZE 4096

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"

// 线程池结构体
typedef struct thread_pool {
    pthread_t threads[THREAD_POOL_SIZE]; // 线程数组
    int queue[QUEUE_SIZE]; // 任务队列
    int head; // 任务队列的头部
    int tail; // 任务队列的尾部
    int clnt_socks[MAX_CONN]; // 存储客户端套接字的数组
    int clnt_cnt; // 连接的客户端数量
    sem_t sem_queue; // 任务队列的信号量
    pthread_mutex_t mutex_queue; // 互斥锁，用于保护任务队列的并发访问
    pthread_cond_t queue_not_full; // 条件变量，用于判断任务队列是否已满
    pthread_cond_t queue_not_empty; // 条件变量，用于判断任务队列是否为空
    int shutdown; // 表示线程池是否关闭
} thread_pool_t;

thread_pool_t pool;

int serv_sock;
int clnt_sock;

void print_perror(char *str) {
    perror(str);
    exit(1);
}

void divide_request(char *req, ssize_t req_len, char *method,char *url,char *version,char *host)
{
    ssize_t s1 = 0;
    while(s1 < req_len && req[s1] != ' ') {
        method[s1] = req[s1];
        s1++;
    }
    method[s1] = '\0';
    ssize_t s2 = s1 + 1;
    while(s2 < req_len && req[s2] != ' ') {
        url[s2 - s1 - 1] = req[s2];
        s2++;
    }
    url[s2 - s1 - 1] = '\0';
    ssize_t s3 = s2 + 1;
    while(s3 < req_len && req[s3] != '\n') {
        version[s3 - s2 - 1] = req[s3];
        s3++;
    }
    version[s3 - s2 - 1] = '\n';
    version[s3- s2] = '\0';
    ssize_t s4 = s3 + 1;
    while(s4 < req_len && req[s4] != '\n') {
        host[s4 - s3 - 1] = req[s4];
        s4++;
    }
    host[s4 - s3 - 1] = '\n';
    host[s4 - s3] = '\0';
}

// 解析 HTTP 请求
int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len, char *version)
{
    char* req = request;
    char *method = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *url = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *host = (char *)malloc(MAX_RECV_LEN * sizeof(char));
    //char *version = (char*) malloc(MAX_RECV_LEN * sizeof(char));

    divide_request(req, req_len, method, url, version, host);
    ssize_t url_len = strlen(url);
    ssize_t host_len = strlen(host);
    //ssize_t ver_len = strlen(version);
    // 如果请求的方法不为GET/请求的URL不以'/'开头/请求的版本号不为HTTP/开头或不以\r\n结尾，则返回错误
    if (strcmp(method,"GET") != 0 || url[0] != '/' ||
        (strncmp(version,"HTTP/1.0\r\n",10) != 0 && strncmp(version, "HTTP/1.1\r\n",10) != 0) ||
        strncmp(host, "Host: ", 6) != 0 || host[host_len-2] != '\r' || host[host_len-1] != '\n') {
        return -1;
    }
    memcpy(path,url,url_len+1);
    *path_len = url_len;
    return 0;
}

int get_content(char *path, long *file_size, FILE **file)
{
    char cur_dir[MAX_PATH_LEN];
    if(getcwd(cur_dir,sizeof(cur_dir)) == NULL) {
        perror("getcwd error!\n");
        return -1;
    }
    char *file_path = (char*) malloc(MAX_PATH_LEN * 2 * sizeof(char));
    if(file_path == NULL) {
        perror("malloc error!\n");
        return -1;
    }

    if(strlen(cur_dir) + strlen(path) + 2 > 2*MAX_PATH_LEN) {
        free(file_path);
        return -1;
    }
    snprintf(file_path, 2*MAX_PATH_LEN, "%s%s", cur_dir, path);

    struct stat path_stat;
    if(stat(file_path, &path_stat) == -1) {
        return -2;
    }
    if(S_ISDIR(path_stat.st_mode)) {
        fprintf(stderr, "%s is a directory!\n", file_path);
        return -1;
    }
    if(access(file_path, F_OK) == -1) {
        // 请求资源不存在时，返回-2
        perror("access error!\n");
        return -2;
    }

    // 判断访问路径是否跳出当前路径
    char *real_path = realpath(file_path, NULL);
    if(real_path == NULL) {
        perror("realpath error!\n");
        free(file_path);
        return -1;
    }
    // 检查绝对路径是否以当前目录为前缀
    if (strncmp(real_path, cur_dir, strlen(cur_dir)) != 0) {
        fprintf(stderr, "Error: Path traversal attempt detected\n");
        free(real_path);
        free(file_path);
        return -1;
    }
    
    *file = fopen(file_path, "r");
    if (*file == NULL) {
        perror("fopen error!\n");
        free(file_path);
        return -2;
    }

    fseek(*file, 0, SEEK_END);
    *file_size = ftell(*file);
    fseek(*file, 0, SEEK_SET);

    free(file_path);
    return 0;
}

int write_response(char *response, int ret, int ret_2, long file_size, int clnt_sock) 
{
    if(ret == -1 || ret_2 == -1) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_500);
    }
    else if(ret_2 == -2) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_404);
    }
    else if(ret == 0 && ret_2 == 0) {
        sprintf(response,
            "HTTP/1.0 %s\r\nContent-Length: %zd\r\n\r\n",
            HTTP_STATUS_200, file_size);
    }
    ssize_t response_len = strlen(response);

    // 写入响应，直到所有数据都被写入
    ssize_t write_len = 0;
    while(response_len > 0) {
        if((write_len = write(clnt_sock, response, response_len)) < 0) {
            perror("write error!\n");
            return -1;
        }
        response += write_len;
        response_len -= write_len;
    }
    return 0;
}

void handle_clnt(int clnt_sock)
{
    // 读取客户端发送来的数据，并解析
    char* req_buf = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char* version = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    // 构造要返回的数据
    // 注意，响应头部后需要有一个多余换行（\r\n\r\n），然后才是响应内容
    char* response = (char*) malloc(MAX_SEND_LEN * sizeof(char));
    // 根据 HTTP 请求的内容，解析资源路径和 Host 头
    char* path = (char*) malloc(MAX_PATH_LEN * sizeof(char));

    ssize_t req_len = 0;
    ssize_t n = 0;
    ssize_t max_recv_len = MAX_RECV_LEN;
    // 读取请求，直到遇到 "\r\n\r\n"
    while (1) {
        n = read(clnt_sock, req_buf + req_len, max_recv_len - req_len);
        if(n < 0) {
            if(errno == EINTR) continue;
            perror("read error!\n");
            goto end;
        }
        req_len += n;
        if(strlen(req_buf) >= 3 && strncmp(req_buf, "GET", 3) != 0) {
            write_response(response, -1, -1, 0, clnt_sock);
            goto end;
        }
        if (req_len >= 4 && strcmp(req_buf + req_len - 4, "\r\n\r\n") == 0) {
            break;
        }
        if(req_len >= max_recv_len) {
            max_recv_len *= 2;
            char *new_req_buf = (char *)realloc(req_buf, max_recv_len * sizeof(char));
            if(!new_req_buf) {
                perror("realloc error!\n");
                goto end;
            }
            req_buf = new_req_buf;
        }   
    }

    ssize_t path_len;
    int ret_1 = parse_request(req_buf, req_len, path, &path_len, version);
    long file_size;
    //char* content = NULL;
    FILE *file = NULL;
    int ret_2 = get_content(path, &file_size, &file);
    
    if(write_response(response, ret_1, ret_2, file_size, clnt_sock) == -1){
        goto end;
    }
    if(ret_2 == 0) {
        char buffer[BUFFER_SIZE];
        while (!feof(file)) {
            size_t n = fread(buffer, 1, BUFFER_SIZE, file);
            if (n < 0) {
                perror("read error!\n");
                break;
            }
            ssize_t write_len = 0;
            while (write_len < n) {
                ssize_t ret = write(clnt_sock, buffer + write_len, n - write_len);
                if (ret < 0) {
                    if(errno == EINTR) continue;
                    perror("write error!\n");
                    break;
                }
                write_len += ret;
            }
        }
        fclose(file);
    }
end:
    // 释放内存
    free(req_buf);
    free(path);
    free(response);
    free(version);
    //if(file != NULL)
      //  fclose(file);
    return;
}

void *thread_func(void* arg)
{
    while (1)
    {
        // 等待信号量
        sem_wait(&pool.sem_queue);
        // 从任务队列中取出一个任务
        pthread_mutex_lock(&pool.mutex_queue);
        int clnt_sock = pool.queue[pool.head];
        pool.head = (pool.head + 1) % MAX_CONN;
        if((pool.tail + 1) % MAX_CONN != pool.head) {
            pthread_cond_signal(&pool.queue_not_full);
        }
        pthread_mutex_unlock(&pool.mutex_queue);
        if(pool.shutdown) {
            break;
        }
        // 处理任务
        handle_clnt(clnt_sock);
        close(clnt_sock);
    }
    return NULL;
}

int main(){
    // 创建套接字，参数说明：
    //   AF_INET: 使用 IPv4
    //   SOCK_STREAM: 面向连接的数据传输方式
    //   IPPROTO_TCP: 使用 TCP 协议
    if((serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
        print_perror("socket error!\n");

    // 将套接字和指定的 IP、端口绑定
    //   用 0 填充 serv_addr（它是一个 sockaddr_in 结构体）
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    //   设置 IPv4
    //   设置 IP 地址
    //   设置端口
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
    serv_addr.sin_port = htons(BIND_PORT);
    //   绑定
    if(bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1)
        print_perror("bind error!\n");

    // 使得 serv_sock 套接字进入监听状态，开始等待客户端发起请求
    if(listen(serv_sock, MAX_CONN) == -1)
        print_perror("listen error!\n");

    // 接收客户端请求，获得一个可以与客户端通信的新的生成的套接字 clnt_sock
    struct sockaddr_in clnt_addr;
    socklen_t clnt_addr_size = sizeof(clnt_addr);

    // 初始化线程池
    sem_init(&pool.sem_queue, 0, 0);
    pthread_mutex_init(&pool.mutex_queue, NULL);
    pthread_cond_init(&pool.queue_not_full, NULL);
    pthread_cond_init(&pool.queue_not_empty, NULL);
    pool.head = 0;
    pool.tail = 0;
    pool.clnt_cnt = 0;
    for(int i = 0;i < THREAD_POOL_SIZE;i++)
    {
        if(pthread_create(&pool.threads[i], NULL, thread_func, NULL) == -1)
            print_perror("pthread_create error!\n");
    }

    while (1) // 一直循环
    {
        // 当没有客户端连接时，accept() 会阻塞程序执行，直到有客户端连接进来
        clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
        if(clnt_sock == -1) {
            perror("accept error!\n");
            continue;
        }
        // 处理客户端的请求
        //handle_clnt(clnt_sock);
        pthread_mutex_lock(&pool.mutex_queue);
        // 线程池已满时等待
        while((pool.tail + 1) % MAX_CONN == pool.head) {
            pthread_cond_wait(&pool.queue_not_full, &pool.mutex_queue);
        }
        pool.queue[pool.tail] = clnt_sock;
        pool.clnt_socks[pool.clnt_cnt++] = clnt_sock;
        pool.tail = (pool.tail + 1) % MAX_CONN;
        if(pool.head != pool.tail) {
            pthread_cond_signal(&pool.queue_not_empty);
        }
        pthread_mutex_unlock(&pool.mutex_queue);
        sem_post(&pool.sem_queue);
    }
    
    // 实际上这里的代码不可到达，可以在 while 循环中收到 SIGINT 信号时主动 break
    // 关闭套接字
    close(serv_sock);
    return 0;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>
#include <semaphore.h>
#include <signal.h>
#include <ctype.h>
#include <sys/stat.h>
#include <errno.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 100
#define QUEUE_SIZE 40960
#define BUFFER_SIZE 4096

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"

// 线程池结构体
typedef struct thread_pool {
    pthread_t threads[THREAD_POOL_SIZE]; // 线程数组
    int queue[QUEUE_SIZE]; // 任务队列
    int head; // 任务队列的头部
    int tail; // 任务队列的尾部
    int clnt_socks[MAX_CONN]; // 存储客户端套接字的数组
    int clnt_cnt; // 连接的客户端数量
    sem_t sem_queue; // 任务队列的信号量
    pthread_mutex_t mutex_queue; // 互斥锁，用于保护任务队列的并发访问
    pthread_cond_t queue_not_full; // 条件变量，用于判断任务队列是否已满
    pthread_cond_t queue_not_empty; // 条件变量，用于判断任务队列是否为空
    int shutdown; // 表示线程池是否关闭
} thread_pool_t;

thread_pool_t pool;

int serv_sock;
int clnt_sock;

void print_perror(char *str) {
    perror(str);
    exit(1);
}

void divide_request(char *req, ssize_t req_len, char *method,char *url,char *version,char *host)
{
    ssize_t s1 = 0;
    while(s1 < req_len && req[s1] != ' ') {
        method[s1] = req[s1];
        s1++;
    }
    method[s1] = '\0';
    ssize_t s2 = s1 + 1;
    while(s2 < req_len && req[s2] != ' ') {
        url[s2 - s1 - 1] = req[s2];
        s2++;
    }
    url[s2 - s1 - 1] = '\0';
    ssize_t s3 = s2 + 1;
    while(s3 < req_len && req[s3] != '\n') {
        version[s3 - s2 - 1] = req[s3];
        s3++;
    }
    version[s3 - s2 - 1] = '\n';
    version[s3- s2] = '\0';
    ssize_t s4 = s3 + 1;
    while(s4 < req_len && req[s4] != '\n') {
        host[s4 - s3 - 1] = req[s4];
        s4++;
    }
    host[s4 - s3 - 1] = '\n';
    host[s4 - s3] = '\0';
}

// 解析 HTTP 请求
int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len, char *version)
{
    char* req = request;
    char *method = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *url = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *host = (char *)malloc(MAX_RECV_LEN * sizeof(char));
    //char *version = (char*) malloc(MAX_RECV_LEN * sizeof(char));

    divide_request(req, req_len, method, url, version, host);
    ssize_t url_len = strlen(url);
    ssize_t host_len = strlen(host);
    //ssize_t ver_len = strlen(version);
    // 如果请求的方法不为GET/请求的URL不以'/'开头/请求的版本号不为HTTP/开头或不以\r\n结尾，则返回错误
    if (strcmp(method,"GET") != 0 || url[0] != '/' ||
        (strncmp(version,"HTTP/1.0\r\n",10) != 0 && strncmp(version, "HTTP/1.1\r\n",10) != 0) ||
        strncmp(host, "Host: ", 6) != 0 || host[host_len-2] != '\r' || host[host_len-1] != '\n') {
        return -1;
    }
    memcpy(path,url,url_len+1);
    *path_len = url_len;
    return 0;
}

int get_content(char *path, long *file_size, FILE **file)
{
    char cur_dir[MAX_PATH_LEN];
    if(getcwd(cur_dir,sizeof(cur_dir)) == NULL) {
        perror("getcwd error!\n");
        return -1;
    }
    char *file_path = (char*) malloc(MAX_PATH_LEN * 2 * sizeof(char));
    if(file_path == NULL) {
        perror("malloc error!\n");
        return -1;
    }

    if(strlen(cur_dir) + strlen(path) + 2 > 2*MAX_PATH_LEN) {
        free(file_path);
        return -1;
    }
    snprintf(file_path, 2*MAX_PATH_LEN, "%s%s", cur_dir, path);

    struct stat path_stat;
    if(stat(file_path, &path_stat) == -1) {
        return -2;
    }
    if(S_ISDIR(path_stat.st_mode)) {
        fprintf(stderr, "%s is a directory!\n", file_path);
        return -1;
    }
    if(access(file_path, F_OK) == -1) {
        // 请求资源不存在时，返回-2
        perror("access error!\n");
        return -2;
    }

    // 判断访问路径是否跳出当前路径
    char *real_path = realpath(file_path, NULL);
    if(real_path == NULL) {
        perror("realpath error!\n");
        free(file_path);
        return -1;
    }
    // 检查绝对路径是否以当前目录为前缀
    if (strncmp(real_path, cur_dir, strlen(cur_dir)) != 0) {
        fprintf(stderr, "Error: Path traversal attempt detected\n");
        free(real_path);
        free(file_path);
        return -1;
    }
    
    *file = fopen(file_path, "r");
    if (*file == NULL) {
        perror("fopen error!\n");
        free(file_path);
        return -2;
    }

    fseek(*file, 0, SEEK_END);
    *file_size = ftell(*file);
    fseek(*file, 0, SEEK_SET);

    free(file_path);
    return 0;
}

int write_response(char *response, int ret, int ret_2, long file_size, int clnt_sock) 
{
    if(ret == -1 || ret_2 == -1) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_500);
    }
    else if(ret_2 == -2) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_404);
    }
    else if(ret == 0 && ret_2 == 0) {
        sprintf(response,
            "HTTP/1.0 %s\r\nContent-Length: %zd\r\n\r\n",
            HTTP_STATUS_200, file_size);
    }
    ssize_t response_len = strlen(response);

    // 写入响应，直到所有数据都被写入
    ssize_t write_len = 0;
    while(response_len > 0) {
        if((write_len = write(clnt_sock, response, response_len)) < 0) {
            perror("write error!\n");
            return -1;
        }
        response += write_len;
        response_len -= write_len;
    }
    return 0;
}

void handle_clnt(int clnt_sock)
{
    // 读取客户端发送来的数据，并解析
    char* req_buf = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char* version = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    // 构造要返回的数据
    // 注意，响应头部后需要有一个多余换行（\r\n\r\n），然后才是响应内容
    char* response = (char*) malloc(MAX_SEND_LEN * sizeof(char));
    // 根据 HTTP 请求的内容，解析资源路径和 Host 头
    char* path = (char*) malloc(MAX_PATH_LEN * sizeof(char));

    ssize_t req_len = 0;
    ssize_t n = 0;
    ssize_t max_recv_len = MAX_RECV_LEN;
    // 读取请求，直到遇到 "\r\n\r\n"
    while (1) {
        n = read(clnt_sock, req_buf + req_len, max_recv_len - req_len);
        if(n < 0) {
            if(errno == EINTR) continue;
            perror("read error!\n");
            goto end;
        }
        req_len += n;
        if(strlen(req_buf) >= 3 && strncmp(req_buf, "GET", 3) != 0) {
            write_response(response, -1, -1, 0, clnt_sock);
            goto end;
        }
        if (req_len >= 4 && strcmp(req_buf + req_len - 4, "\r\n\r\n") == 0) {
            break;
        }
        if(req_len >= max_recv_len) {
            max_recv_len *= 2;
            char *new_req_buf = (char *)realloc(req_buf, max_recv_len * sizeof(char));
            if(!new_req_buf) {
                perror("realloc error!\n");
                goto end;
            }
            req_buf = new_req_buf;
        }   
    }

    ssize_t path_len;
    int ret_1 = parse_request(req_buf, req_len, path, &path_len, version);
    long file_size;
    //char* content = NULL;
    FILE *file = NULL;
    int ret_2 = get_content(path, &file_size, &file);
    
    if(write_response(response, ret_1, ret_2, file_size, clnt_sock) == -1){
        goto end;
    }
    if(ret_2 == 0) {
        char buffer[BUFFER_SIZE];
        while (!feof(file)) {
            size_t n = fread(buffer, 1, BUFFER_SIZE, file);
            if (n < 0) {
                perror("read error!\n");
                break;
            }
            ssize_t write_len = 0;
            while (write_len < n) {
                ssize_t ret = write(clnt_sock, buffer + write_len, n - write_len);
                if (ret < 0) {
                    if(errno == EINTR) continue;
                    perror("write error!\n");
                    break;
                }
                write_len += ret;
            }
        }
        fclose(file);
    }
end:
    // 释放内存
    free(req_buf);
    free(path);
    free(response);
    free(version);
    //if(file != NULL)
      //  fclose(file);
    return;
}

void *thread_func(void* arg)
{
    while (1)
    {
        // 等待信号量
        sem_wait(&pool.sem_queue);
        // 从任务队列中取出一个任务
        pthread_mutex_lock(&pool.mutex_queue);
        int clnt_sock = pool.queue[pool.head];
        pool.head = (pool.head + 1) % MAX_CONN;
        if((pool.tail + 1) % MAX_CONN != pool.head) {
            pthread_cond_signal(&pool.queue_not_full);
        }
        pthread_mutex_unlock(&pool.mutex_queue);
        if(pool.shutdown) {
            break;
        }
        // 处理任务
        handle_clnt(clnt_sock);
        close(clnt_sock);
    }
    return NULL;
}

int main(){
    // 创建套接字，参数说明：
    //   AF_INET: 使用 IPv4
    //   SOCK_STREAM: 面向连接的数据传输方式
    //   IPPROTO_TCP: 使用 TCP 协议
    if((serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
        print_perror("socket error!\n");

    // 将套接字和指定的 IP、端口绑定
    //   用 0 填充 serv_addr（它是一个 sockaddr_in 结构体）
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    //   设置 IPv4
    //   设置 IP 地址
    //   设置端口
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
    serv_addr.sin_port = htons(BIND_PORT);
    //   绑定
    if(bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1)
        print_perror("bind error!\n");

    // 使得 serv_sock 套接字进入监听状态，开始等待客户端发起请求
    if(listen(serv_sock, MAX_CONN) == -1)
        print_perror("listen error!\n");

    // 接收客户端请求，获得一个可以与客户端通信的新的生成的套接字 clnt_sock
    struct sockaddr_in clnt_addr;
    socklen_t clnt_addr_size = sizeof(clnt_addr);

    // 初始化线程池
    sem_init(&pool.sem_queue, 0, 0);
    pthread_mutex_init(&pool.mutex_queue, NULL);
    pthread_cond_init(&pool.queue_not_full, NULL);
    pthread_cond_init(&pool.queue_not_empty, NULL);
    pool.head = 0;
    pool.tail = 0;
    pool.clnt_cnt = 0;
    for(int i = 0;i < THREAD_POOL_SIZE;i++)
    {
        if(pthread_create(&pool.threads[i], NULL, thread_func, NULL) == -1)
            print_perror("pthread_create error!\n");
    }

    while (1) // 一直循环
    {
        // 当没有客户端连接时，accept() 会阻塞程序执行，直到有客户端连接进来
        clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
        if(clnt_sock == -1) {
            perror("accept error!\n");
            continue;
        }
        // 处理客户端的请求
        //handle_clnt(clnt_sock);
        pthread_mutex_lock(&pool.mutex_queue);
        // 线程池已满时等待
        while((pool.tail + 1) % MAX_CONN == pool.head) {
            pthread_cond_wait(&pool.queue_not_full, &pool.mutex_queue);
        }
        pool.queue[pool.tail] = clnt_sock;
        pool.clnt_socks[pool.clnt_cnt++] = clnt_sock;
        pool.tail = (pool.tail + 1) % MAX_CONN;
        if(pool.head != pool.tail) {
            pthread_cond_signal(&pool.queue_not_empty);
        }
        pthread_mutex_unlock(&pool.mutex_queue);
        sem_post(&pool.sem_queue);
    }
    
    // 实际上这里的代码不可到达，可以在 while 循环中收到 SIGINT 信号时主动 break
    // 关闭套接字
    close(serv_sock);
    return 0;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>
#include <semaphore.h>
#include <signal.h>
#include <ctype.h>
#include <sys/stat.h>
#include <errno.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 100
#define QUEUE_SIZE 40960
#define BUFFER_SIZE 4096

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"

// 线程池结构体
typedef struct thread_pool {
    pthread_t threads[THREAD_POOL_SIZE]; // 线程数组
    int queue[QUEUE_SIZE]; // 任务队列
    int head; // 任务队列的头部
    int tail; // 任务队列的尾部
    int clnt_socks[MAX_CONN]; // 存储客户端套接字的数组
    int clnt_cnt; // 连接的客户端数量
    sem_t sem_queue; // 任务队列的信号量
    pthread_mutex_t mutex_queue; // 互斥锁，用于保护任务队列的并发访问
    pthread_cond_t queue_not_full; // 条件变量，用于判断任务队列是否已满
    pthread_cond_t queue_not_empty; // 条件变量，用于判断任务队列是否为空
    int shutdown; // 表示线程池是否关闭
} thread_pool_t;

thread_pool_t pool;

int serv_sock;
int clnt_sock;

void print_perror(char *str) {
    perror(str);
    exit(1);
}

void divide_request(char *req, ssize_t req_len, char *method,char *url,char *version,char *host)
{
    ssize_t s1 = 0;
    while(s1 < req_len && req[s1] != ' ') {
        method[s1] = req[s1];
        s1++;
    }
    method[s1] = '\0';
    ssize_t s2 = s1 + 1;
    while(s2 < req_len && req[s2] != ' ') {
        url[s2 - s1 - 1] = req[s2];
        s2++;
    }
    url[s2 - s1 - 1] = '\0';
    ssize_t s3 = s2 + 1;
    while(s3 < req_len && req[s3] != '\n') {
        version[s3 - s2 - 1] = req[s3];
        s3++;
    }
    version[s3 - s2 - 1] = '\n';
    version[s3- s2] = '\0';
    ssize_t s4 = s3 + 1;
    while(s4 < req_len && req[s4] != '\n') {
        host[s4 - s3 - 1] = req[s4];
        s4++;
    }
    host[s4 - s3 - 1] = '\n';
    host[s4 - s3] = '\0';
}

// 解析 HTTP 请求
int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len, char *version)
{
    char* req = request;
    char *method = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *url = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *host = (char *)malloc(MAX_RECV_LEN * sizeof(char));
    //char *version = (char*) malloc(MAX_RECV_LEN * sizeof(char));

    divide_request(req, req_len, method, url, version, host);
    ssize_t url_len = strlen(url);
    ssize_t host_len = strlen(host);
    //ssize_t ver_len = strlen(version);
    // 如果请求的方法不为GET/请求的URL不以'/'开头/请求的版本号不为HTTP/开头或不以\r\n结尾，则返回错误
    if (strcmp(method,"GET") != 0 || url[0] != '/' ||
        (strncmp(version,"HTTP/1.0\r\n",10) != 0 && strncmp(version, "HTTP/1.1\r\n",10) != 0) ||
        strncmp(host, "Host: ", 6) != 0 || host[host_len-2] != '\r' || host[host_len-1] != '\n') {
        return -1;
    }
    memcpy(path,url,url_len+1);
    *path_len = url_len;
    return 0;
}

int get_content(char *path, long *file_size, FILE **file)
{
    char cur_dir[MAX_PATH_LEN];
    if(getcwd(cur_dir,sizeof(cur_dir)) == NULL) {
        perror("getcwd error!\n");
        return -1;
    }
    char *file_path = (char*) malloc(MAX_PATH_LEN * 2 * sizeof(char));
    if(file_path == NULL) {
        perror("malloc error!\n");
        return -1;
    }

    if(strlen(cur_dir) + strlen(path) + 2 > 2*MAX_PATH_LEN) {
        free(file_path);
        return -1;
    }
    snprintf(file_path, 2*MAX_PATH_LEN, "%s%s", cur_dir, path);

    struct stat path_stat;
    if(stat(file_path, &path_stat) == -1) {
        return -2;
    }
    if(S_ISDIR(path_stat.st_mode)) {
        fprintf(stderr, "%s is a directory!\n", file_path);
        return -1;
    }
    if(access(file_path, F_OK) == -1) {
        // 请求资源不存在时，返回-2
        perror("access error!\n");
        return -2;
    }

    // 判断访问路径是否跳出当前路径
    char *real_path = realpath(file_path, NULL);
    if(real_path == NULL) {
        perror("realpath error!\n");
        free(file_path);
        return -1;
    }
    // 检查绝对路径是否以当前目录为前缀
    if (strncmp(real_path, cur_dir, strlen(cur_dir)) != 0) {
        fprintf(stderr, "Error: Path traversal attempt detected\n");
        free(real_path);
        free(file_path);
        return -1;
    }
    
    *file = fopen(file_path, "r");
    if (*file == NULL) {
        perror("fopen error!\n");
        free(file_path);
        return -2;
    }

    fseek(*file, 0, SEEK_END);
    *file_size = ftell(*file);
    fseek(*file, 0, SEEK_SET);

    free(file_path);
    return 0;
}

int write_response(char *response, int ret, int ret_2, long file_size, int clnt_sock) 
{
    if(ret == -1 || ret_2 == -1) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_500);
    }
    else if(ret_2 == -2) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_404);
    }
    else if(ret == 0 && ret_2 == 0) {
        sprintf(response,
            "HTTP/1.0 %s\r\nContent-Length: %zd\r\n\r\n",
            HTTP_STATUS_200, file_size);
    }
    ssize_t response_len = strlen(response);

    // 写入响应，直到所有数据都被写入
    ssize_t write_len = 0;
    while(response_len > 0) {
        if((write_len = write(clnt_sock, response, response_len)) < 0) {
            perror("write error!\n");
            return -1;
        }
        response += write_len;
        response_len -= write_len;
    }
    return 0;
}

void handle_clnt(int clnt_sock)
{
    // 读取客户端发送来的数据，并解析
    char* req_buf = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char* version = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    // 构造要返回的数据
    // 注意，响应头部后需要有一个多余换行（\r\n\r\n），然后才是响应内容
    char* response = (char*) malloc(MAX_SEND_LEN * sizeof(char));
    // 根据 HTTP 请求的内容，解析资源路径和 Host 头
    char* path = (char*) malloc(MAX_PATH_LEN * sizeof(char));

    ssize_t req_len = 0;
    ssize_t n = 0;
    ssize_t max_recv_len = MAX_RECV_LEN;
    // 读取请求，直到遇到 "\r\n\r\n"
    while (1) {
        n = read(clnt_sock, req_buf + req_len, max_recv_len - req_len);
        if(n < 0) {
            if(errno == EINTR) continue;
            perror("read error!\n");
            goto end;
        }
        req_len += n;
        if(strlen(req_buf) >= 3 && strncmp(req_buf, "GET", 3) != 0) {
            write_response(response, -1, -1, 0, clnt_sock);
            goto end;
        }
        if (req_len >= 4 && strcmp(req_buf + req_len - 4, "\r\n\r\n") == 0) {
            break;
        }
        if(req_len >= max_recv_len) {
            max_recv_len *= 2;
            char *new_req_buf = (char *)realloc(req_buf, max_recv_len * sizeof(char));
            if(!new_req_buf) {
                perror("realloc error!\n");
                goto end;
            }
            req_buf = new_req_buf;
        }   
    }

    ssize_t path_len;
    int ret_1 = parse_request(req_buf, req_len, path, &path_len, version);
    long file_size;
    //char* content = NULL;
    FILE *file = NULL;
    int ret_2 = get_content(path, &file_size, &file);
    
    if(write_response(response, ret_1, ret_2, file_size, clnt_sock) == -1){
        goto end;
    }
    if(ret_2 == 0) {
        char buffer[BUFFER_SIZE];
        while (!feof(file)) {
            size_t n = fread(buffer, 1, BUFFER_SIZE, file);
            if (n < 0) {
                perror("read error!\n");
                break;
            }
            ssize_t write_len = 0;
            while (write_len < n) {
                ssize_t ret = write(clnt_sock, buffer + write_len, n - write_len);
                if (ret < 0) {
                    if(errno == EINTR) continue;
                    perror("write error!\n");
                    break;
                }
                write_len += ret;
            }
        }
        fclose(file);
    }
end:
    // 释放内存
    free(req_buf);
    free(path);
    free(response);
    free(version);
    //if(file != NULL)
      //  fclose(file);
    return;
}

void *thread_func(void* arg)
{
    while (1)
    {
        // 等待信号量
        sem_wait(&pool.sem_queue);
        // 从任务队列中取出一个任务
        pthread_mutex_lock(&pool.mutex_queue);
        int clnt_sock = pool.queue[pool.head];
        pool.head = (pool.head + 1) % MAX_CONN;
        if((pool.tail + 1) % MAX_CONN != pool.head) {
            pthread_cond_signal(&pool.queue_not_full);
        }
        pthread_mutex_unlock(&pool.mutex_queue);
        if(pool.shutdown) {
            break;
        }
        // 处理任务
        handle_clnt(clnt_sock);
        close(clnt_sock);
    }
    return NULL;
}

int main(){
    // 创建套接字，参数说明：
    //   AF_INET: 使用 IPv4
    //   SOCK_STREAM: 面向连接的数据传输方式
    //   IPPROTO_TCP: 使用 TCP 协议
    if((serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
        print_perror("socket error!\n");

    // 将套接字和指定的 IP、端口绑定
    //   用 0 填充 serv_addr（它是一个 sockaddr_in 结构体）
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    //   设置 IPv4
    //   设置 IP 地址
    //   设置端口
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
    serv_addr.sin_port = htons(BIND_PORT);
    //   绑定
    if(bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1)
        print_perror("bind error!\n");

    // 使得 serv_sock 套接字进入监听状态，开始等待客户端发起请求
    if(listen(serv_sock, MAX_CONN) == -1)
        print_perror("listen error!\n");

    // 接收客户端请求，获得一个可以与客户端通信的新的生成的套接字 clnt_sock
    struct sockaddr_in clnt_addr;
    socklen_t clnt_addr_size = sizeof(clnt_addr);

    // 初始化线程池
    sem_init(&pool.sem_queue, 0, 0);
    pthread_mutex_init(&pool.mutex_queue, NULL);
    pthread_cond_init(&pool.queue_not_full, NULL);
    pthread_cond_init(&pool.queue_not_empty, NULL);
    pool.head = 0;
    pool.tail = 0;
    pool.clnt_cnt = 0;
    for(int i = 0;i < THREAD_POOL_SIZE;i++)
    {
        if(pthread_create(&pool.threads[i], NULL, thread_func, NULL) == -1)
            print_perror("pthread_create error!\n");
    }

    while (1) // 一直循环
    {
        // 当没有客户端连接时，accept() 会阻塞程序执行，直到有客户端连接进来
        clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
        if(clnt_sock == -1) {
            perror("accept error!\n");
            continue;
        }
        // 处理客户端的请求
        //handle_clnt(clnt_sock);
        pthread_mutex_lock(&pool.mutex_queue);
        // 线程池已满时等待
        while((pool.tail + 1) % MAX_CONN == pool.head) {
            pthread_cond_wait(&pool.queue_not_full, &pool.mutex_queue);
        }
        pool.queue[pool.tail] = clnt_sock;
        pool.clnt_socks[pool.clnt_cnt++] = clnt_sock;
        pool.tail = (pool.tail + 1) % MAX_CONN;
        if(pool.head != pool.tail) {
            pthread_cond_signal(&pool.queue_not_empty);
        }
        pthread_mutex_unlock(&pool.mutex_queue);
        sem_post(&pool.sem_queue);
    }
    
    // 实际上这里的代码不可到达，可以在 while 循环中收到 SIGINT 信号时主动 break
    // 关闭套接字
    close(serv_sock);
    return 0;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>
#include <semaphore.h>
#include <signal.h>
#include <ctype.h>
#include <sys/stat.h>
#include <errno.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 100
#define QUEUE_SIZE 40960
#define BUFFER_SIZE 4096

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"

// 线程池结构体
typedef struct thread_pool {
    pthread_t threads[THREAD_POOL_SIZE]; // 线程数组
    int queue[QUEUE_SIZE]; // 任务队列
    int head; // 任务队列的头部
    int tail; // 任务队列的尾部
    int clnt_socks[MAX_CONN]; // 存储客户端套接字的数组
    int clnt_cnt; // 连接的客户端数量
    sem_t sem_queue; // 任务队列的信号量
    pthread_mutex_t mutex_queue; // 互斥锁，用于保护任务队列的并发访问
    pthread_cond_t queue_not_full; // 条件变量，用于判断任务队列是否已满
    pthread_cond_t queue_not_empty; // 条件变量，用于判断任务队列是否为空
    int shutdown; // 表示线程池是否关闭
} thread_pool_t;

thread_pool_t pool;

int serv_sock;
int clnt_sock;

void print_perror(char *str) {
    perror(str);
    exit(1);
}

void divide_request(char *req, ssize_t req_len, char *method,char *url,char *version,char *host)
{
    ssize_t s1 = 0;
    while(s1 < req_len && req[s1] != ' ') {
        method[s1] = req[s1];
        s1++;
    }
    method[s1] = '\0';
    ssize_t s2 = s1 + 1;
    while(s2 < req_len && req[s2] != ' ') {
        url[s2 - s1 - 1] = req[s2];
        s2++;
    }
    url[s2 - s1 - 1] = '\0';
    ssize_t s3 = s2 + 1;
    while(s3 < req_len && req[s3] != '\n') {
        version[s3 - s2 - 1] = req[s3];
        s3++;
    }
    version[s3 - s2 - 1] = '\n';
    version[s3- s2] = '\0';
    ssize_t s4 = s3 + 1;
    while(s4 < req_len && req[s4] != '\n') {
        host[s4 - s3 - 1] = req[s4];
        s4++;
    }
    host[s4 - s3 - 1] = '\n';
    host[s4 - s3] = '\0';
}

// 解析 HTTP 请求
int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len, char *version)
{
    char* req = request;
    char *method = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *url = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *host = (char *)malloc(MAX_RECV_LEN * sizeof(char));
    //char *version = (char*) malloc(MAX_RECV_LEN * sizeof(char));

    divide_request(req, req_len, method, url, version, host);
    ssize_t url_len = strlen(url);
    ssize_t host_len = strlen(host);
    //ssize_t ver_len = strlen(version);
    // 如果请求的方法不为GET/请求的URL不以'/'开头/请求的版本号不为HTTP/开头或不以\r\n结尾，则返回错误
    if (strcmp(method,"GET") != 0 || url[0] != '/' ||
        (strncmp(version,"HTTP/1.0\r\n",10) != 0 && strncmp(version, "HTTP/1.1\r\n",10) != 0) ||
        strncmp(host, "Host: ", 6) != 0 || host[host_len-2] != '\r' || host[host_len-1] != '\n') {
        return -1;
    }
    memcpy(path,url,url_len+1);
    *path_len = url_len;
    return 0;
}

int get_content(char *path, long *file_size, FILE **file)
{
    char cur_dir[MAX_PATH_LEN];
    if(getcwd(cur_dir,sizeof(cur_dir)) == NULL) {
        perror("getcwd error!\n");
        return -1;
    }
    char *file_path = (char*) malloc(MAX_PATH_LEN * 2 * sizeof(char));
    if(file_path == NULL) {
        perror("malloc error!\n");
        return -1;
    }

    if(strlen(cur_dir) + strlen(path) + 2 > 2*MAX_PATH_LEN) {
        free(file_path);
        return -1;
    }
    snprintf(file_path, 2*MAX_PATH_LEN, "%s%s", cur_dir, path);

    struct stat path_stat;
    if(stat(file_path, &path_stat) == -1) {
        return -2;
    }
    if(S_ISDIR(path_stat.st_mode)) {
        fprintf(stderr, "%s is a directory!\n", file_path);
        return -1;
    }
    if(access(file_path, F_OK) == -1) {
        // 请求资源不存在时，返回-2
        perror("access error!\n");
        return -2;
    }

    // 判断访问路径是否跳出当前路径
    char *real_path = realpath(file_path, NULL);
    if(real_path == NULL) {
        perror("realpath error!\n");
        free(file_path);
        return -1;
    }
    // 检查绝对路径是否以当前目录为前缀
    if (strncmp(real_path, cur_dir, strlen(cur_dir)) != 0) {
        fprintf(stderr, "Error: Path traversal attempt detected\n");
        free(real_path);
        free(file_path);
        return -1;
    }
    
    *file = fopen(file_path, "r");
    if (*file == NULL) {
        perror("fopen error!\n");
        free(file_path);
        return -2;
    }

    fseek(*file, 0, SEEK_END);
    *file_size = ftell(*file);
    fseek(*file, 0, SEEK_SET);

    free(file_path);
    return 0;
}

int write_response(char *response, int ret, int ret_2, long file_size, int clnt_sock) 
{
    if(ret == -1 || ret_2 == -1) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_500);
    }
    else if(ret_2 == -2) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_404);
    }
    else if(ret == 0 && ret_2 == 0) {
        sprintf(response,
            "HTTP/1.0 %s\r\nContent-Length: %zd\r\n\r\n",
            HTTP_STATUS_200, file_size);
    }
    ssize_t response_len = strlen(response);

    // 写入响应，直到所有数据都被写入
    ssize_t write_len = 0;
    while(response_len > 0) {
        if((write_len = write(clnt_sock, response, response_len)) < 0) {
            perror("write error!\n");
            return -1;
        }
        response += write_len;
        response_len -= write_len;
    }
    return 0;
}

void handle_clnt(int clnt_sock)
{
    // 读取客户端发送来的数据，并解析
    char* req_buf = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char* version = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    // 构造要返回的数据
    // 注意，响应头部后需要有一个多余换行（\r\n\r\n），然后才是响应内容
    char* response = (char*) malloc(MAX_SEND_LEN * sizeof(char));
    // 根据 HTTP 请求的内容，解析资源路径和 Host 头
    char* path = (char*) malloc(MAX_PATH_LEN * sizeof(char));

    ssize_t req_len = 0;
    ssize_t n = 0;
    ssize_t max_recv_len = MAX_RECV_LEN;
    // 读取请求，直到遇到 "\r\n\r\n"
    while (1) {
        n = read(clnt_sock, req_buf + req_len, max_recv_len - req_len);
        if(n < 0) {
            if(errno == EINTR) continue;
            perror("read error!\n");
            goto end;
        }
        req_len += n;
        if(strlen(req_buf) >= 3 && strncmp(req_buf, "GET", 3) != 0) {
            write_response(response, -1, -1, 0, clnt_sock);
            goto end;
        }
        if (req_len >= 4 && strcmp(req_buf + req_len - 4, "\r\n\r\n") == 0) {
            break;
        }
        if(req_len >= max_recv_len) {
            max_recv_len *= 2;
            char *new_req_buf = (char *)realloc(req_buf, max_recv_len * sizeof(char));
            if(!new_req_buf) {
                perror("realloc error!\n");
                goto end;
            }
            req_buf = new_req_buf;
        }   
    }

    ssize_t path_len;
    int ret_1 = parse_request(req_buf, req_len, path, &path_len, version);
    long file_size;
    //char* content = NULL;
    FILE *file = NULL;
    int ret_2 = get_content(path, &file_size, &file);
    
    if(write_response(response, ret_1, ret_2, file_size, clnt_sock) == -1){
        goto end;
    }
    if(ret_2 == 0) {
        char buffer[BUFFER_SIZE];
        while (!feof(file)) {
            size_t n = fread(buffer, 1, BUFFER_SIZE, file);
            if (n < 0) {
                perror("read error!\n");
                break;
            }
            ssize_t write_len = 0;
            while (write_len < n) {
                ssize_t ret = write(clnt_sock, buffer + write_len, n - write_len);
                if (ret < 0) {
                    if(errno == EINTR) continue;
                    perror("write error!\n");
                    break;
                }
                write_len += ret;
            }
        }
        fclose(file);
    }
end:
    // 释放内存
    free(req_buf);
    free(path);
    free(response);
    free(version);
    //if(file != NULL)
      //  fclose(file);
    return;
}

void *thread_func(void* arg)
{
    while (1)
    {
        // 等待信号量
        sem_wait(&pool.sem_queue);
        // 从任务队列中取出一个任务
        pthread_mutex_lock(&pool.mutex_queue);
        int clnt_sock = pool.queue[pool.head];
        pool.head = (pool.head + 1) % MAX_CONN;
        if((pool.tail + 1) % MAX_CONN != pool.head) {
            pthread_cond_signal(&pool.queue_not_full);
        }
        pthread_mutex_unlock(&pool.mutex_queue);
        if(pool.shutdown) {
            break;
        }
        // 处理任务
        handle_clnt(clnt_sock);
        close(clnt_sock);
    }
    return NULL;
}

int main(){
    // 创建套接字，参数说明：
    //   AF_INET: 使用 IPv4
    //   SOCK_STREAM: 面向连接的数据传输方式
    //   IPPROTO_TCP: 使用 TCP 协议
    if((serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
        print_perror("socket error!\n");

    // 将套接字和指定的 IP、端口绑定
    //   用 0 填充 serv_addr（它是一个 sockaddr_in 结构体）
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    //   设置 IPv4
    //   设置 IP 地址
    //   设置端口
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
    serv_addr.sin_port = htons(BIND_PORT);
    //   绑定
    if(bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1)
        print_perror("bind error!\n");

    // 使得 serv_sock 套接字进入监听状态，开始等待客户端发起请求
    if(listen(serv_sock, MAX_CONN) == -1)
        print_perror("listen error!\n");

    // 接收客户端请求，获得一个可以与客户端通信的新的生成的套接字 clnt_sock
    struct sockaddr_in clnt_addr;
    socklen_t clnt_addr_size = sizeof(clnt_addr);

    // 初始化线程池
    sem_init(&pool.sem_queue, 0, 0);
    pthread_mutex_init(&pool.mutex_queue, NULL);
    pthread_cond_init(&pool.queue_not_full, NULL);
    pthread_cond_init(&pool.queue_not_empty, NULL);
    pool.head = 0;
    pool.tail = 0;
    pool.clnt_cnt = 0;
    for(int i = 0;i < THREAD_POOL_SIZE;i++)
    {
        if(pthread_create(&pool.threads[i], NULL, thread_func, NULL) == -1)
            print_perror("pthread_create error!\n");
    }

    while (1) // 一直循环
    {
        // 当没有客户端连接时，accept() 会阻塞程序执行，直到有客户端连接进来
        clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
        if(clnt_sock == -1) {
            perror("accept error!\n");
            continue;
        }
        // 处理客户端的请求
        //handle_clnt(clnt_sock);
        pthread_mutex_lock(&pool.mutex_queue);
        // 线程池已满时等待
        while((pool.tail + 1) % MAX_CONN == pool.head) {
            pthread_cond_wait(&pool.queue_not_full, &pool.mutex_queue);
        }
        pool.queue[pool.tail] = clnt_sock;
        pool.clnt_socks[pool.clnt_cnt++] = clnt_sock;
        pool.tail = (pool.tail + 1) % MAX_CONN;
        if(pool.head != pool.tail) {
            pthread_cond_signal(&pool.queue_not_empty);
        }
        pthread_mutex_unlock(&pool.mutex_queue);
        sem_post(&pool.sem_queue);
    }
    
    // 实际上这里的代码不可到达，可以在 while 循环中收到 SIGINT 信号时主动 break
    // 关闭套接字
    close(serv_sock);
    return 0;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>
#include <semaphore.h>
#include <signal.h>
#include <ctype.h>
#include <sys/stat.h>
#include <errno.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 100
#define QUEUE_SIZE 40960
#define BUFFER_SIZE 4096

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"

// 线程池结构体
typedef struct thread_pool {
    pthread_t threads[THREAD_POOL_SIZE]; // 线程数组
    int queue[QUEUE_SIZE]; // 任务队列
    int head; // 任务队列的头部
    int tail; // 任务队列的尾部
    int clnt_socks[MAX_CONN]; // 存储客户端套接字的数组
    int clnt_cnt; // 连接的客户端数量
    sem_t sem_queue; // 任务队列的信号量
    pthread_mutex_t mutex_queue; // 互斥锁，用于保护任务队列的并发访问
    pthread_cond_t queue_not_full; // 条件变量，用于判断任务队列是否已满
    pthread_cond_t queue_not_empty; // 条件变量，用于判断任务队列是否为空
    int shutdown; // 表示线程池是否关闭
} thread_pool_t;

thread_pool_t pool;

int serv_sock;
int clnt_sock;

void print_perror(char *str) {
    perror(str);
    exit(1);
}

void divide_request(char *req, ssize_t req_len, char *method,char *url,char *version,char *host)
{
    ssize_t s1 = 0;
    while(s1 < req_len && req[s1] != ' ') {
        method[s1] = req[s1];
        s1++;
    }
    method[s1] = '\0';
    ssize_t s2 = s1 + 1;
    while(s2 < req_len && req[s2] != ' ') {
        url[s2 - s1 - 1] = req[s2];
        s2++;
    }
    url[s2 - s1 - 1] = '\0';
    ssize_t s3 = s2 + 1;
    while(s3 < req_len && req[s3] != '\n') {
        version[s3 - s2 - 1] = req[s3];
        s3++;
    }
    version[s3 - s2 - 1] = '\n';
    version[s3- s2] = '\0';
    ssize_t s4 = s3 + 1;
    while(s4 < req_len && req[s4] != '\n') {
        host[s4 - s3 - 1] = req[s4];
        s4++;
    }
    host[s4 - s3 - 1] = '\n';
    host[s4 - s3] = '\0';
}

// 解析 HTTP 请求
int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len, char *version)
{
    char* req = request;
    char *method = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *url = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *host = (char *)malloc(MAX_RECV_LEN * sizeof(char));
    //char *version = (char*) malloc(MAX_RECV_LEN * sizeof(char));

    divide_request(req, req_len, method, url, version, host);
    ssize_t url_len = strlen(url);
    ssize_t host_len = strlen(host);
    //ssize_t ver_len = strlen(version);
    // 如果请求的方法不为GET/请求的URL不以'/'开头/请求的版本号不为HTTP/开头或不以\r\n结尾，则返回错误
    if (strcmp(method,"GET") != 0 || url[0] != '/' ||
        (strncmp(version,"HTTP/1.0\r\n",10) != 0 && strncmp(version, "HTTP/1.1\r\n",10) != 0) ||
        strncmp(host, "Host: ", 6) != 0 || host[host_len-2] != '\r' || host[host_len-1] != '\n') {
        return -1;
    }
    memcpy(path,url,url_len+1);
    *path_len = url_len;
    return 0;
}

int get_content(char *path, long *file_size, FILE **file)
{
    char cur_dir[MAX_PATH_LEN];
    if(getcwd(cur_dir,sizeof(cur_dir)) == NULL) {
        perror("getcwd error!\n");
        return -1;
    }
    char *file_path = (char*) malloc(MAX_PATH_LEN * 2 * sizeof(char));
    if(file_path == NULL) {
        perror("malloc error!\n");
        return -1;
    }

    if(strlen(cur_dir) + strlen(path) + 2 > 2*MAX_PATH_LEN) {
        free(file_path);
        return -1;
    }
    snprintf(file_path, 2*MAX_PATH_LEN, "%s%s", cur_dir, path);

    struct stat path_stat;
    if(stat(file_path, &path_stat) == -1) {
        return -2;
    }
    if(S_ISDIR(path_stat.st_mode)) {
        fprintf(stderr, "%s is a directory!\n", file_path);
        return -1;
    }
    if(access(file_path, F_OK) == -1) {
        // 请求资源不存在时，返回-2
        perror("access error!\n");
        return -2;
    }

    // 判断访问路径是否跳出当前路径
    char *real_path = realpath(file_path, NULL);
    if(real_path == NULL) {
        perror("realpath error!\n");
        free(file_path);
        return -1;
    }
    // 检查绝对路径是否以当前目录为前缀
    if (strncmp(real_path, cur_dir, strlen(cur_dir)) != 0) {
        fprintf(stderr, "Error: Path traversal attempt detected\n");
        free(real_path);
        free(file_path);
        return -1;
    }
    
    *file = fopen(file_path, "r");
    if (*file == NULL) {
        perror("fopen error!\n");
        free(file_path);
        return -2;
    }

    fseek(*file, 0, SEEK_END);
    *file_size = ftell(*file);
    fseek(*file, 0, SEEK_SET);

    free(file_path);
    return 0;
}

int write_response(char *response, int ret, int ret_2, long file_size, int clnt_sock) 
{
    if(ret == -1 || ret_2 == -1) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_500);
    }
    else if(ret_2 == -2) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_404);
    }
    else if(ret == 0 && ret_2 == 0) {
        sprintf(response,
            "HTTP/1.0 %s\r\nContent-Length: %zd\r\n\r\n",
            HTTP_STATUS_200, file_size);
    }
    ssize_t response_len = strlen(response);

    // 写入响应，直到所有数据都被写入
    ssize_t write_len = 0;
    while(response_len > 0) {
        if((write_len = write(clnt_sock, response, response_len)) < 0) {
            perror("write error!\n");
            return -1;
        }
        response += write_len;
        response_len -= write_len;
    }
    return 0;
}

void handle_clnt(int clnt_sock)
{
    // 读取客户端发送来的数据，并解析
    char* req_buf = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char* version = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    // 构造要返回的数据
    // 注意，响应头部后需要有一个多余换行（\r\n\r\n），然后才是响应内容
    char* response = (char*) malloc(MAX_SEND_LEN * sizeof(char));
    // 根据 HTTP 请求的内容，解析资源路径和 Host 头
    char* path = (char*) malloc(MAX_PATH_LEN * sizeof(char));

    ssize_t req_len = 0;
    ssize_t n = 0;
    ssize_t max_recv_len = MAX_RECV_LEN;
    // 读取请求，直到遇到 "\r\n\r\n"
    while (1) {
        n = read(clnt_sock, req_buf + req_len, max_recv_len - req_len);
        if(n < 0) {
            if(errno == EINTR) continue;
            perror("read error!\n");
            goto end;
        }
        req_len += n;
        if(strlen(req_buf) >= 3 && strncmp(req_buf, "GET", 3) != 0) {
            write_response(response, -1, -1, 0, clnt_sock);
            goto end;
        }
        if (req_len >= 4 && strcmp(req_buf + req_len - 4, "\r\n\r\n") == 0) {
            break;
        }
        if(req_len >= max_recv_len) {
            max_recv_len *= 2;
            char *new_req_buf = (char *)realloc(req_buf, max_recv_len * sizeof(char));
            if(!new_req_buf) {
                perror("realloc error!\n");
                goto end;
            }
            req_buf = new_req_buf;
        }   
    }

    ssize_t path_len;
    int ret_1 = parse_request(req_buf, req_len, path, &path_len, version);
    long file_size;
    //char* content = NULL;
    FILE *file = NULL;
    int ret_2 = get_content(path, &file_size, &file);
    
    if(write_response(response, ret_1, ret_2, file_size, clnt_sock) == -1){
        goto end;
    }
    if(ret_2 == 0) {
        char buffer[BUFFER_SIZE];
        while (!feof(file)) {
            size_t n = fread(buffer, 1, BUFFER_SIZE, file);
            if (n < 0) {
                perror("read error!\n");
                break;
            }
            ssize_t write_len = 0;
            while (write_len < n) {
                ssize_t ret = write(clnt_sock, buffer + write_len, n - write_len);
                if (ret < 0) {
                    if(errno == EINTR) continue;
                    perror("write error!\n");
                    break;
                }
                write_len += ret;
            }
        }
        fclose(file);
    }
end:
    // 释放内存
    free(req_buf);
    free(path);
    free(response);
    free(version);
    //if(file != NULL)
      //  fclose(file);
    return;
}

void *thread_func(void* arg)
{
    while (1)
    {
        // 等待信号量
        sem_wait(&pool.sem_queue);
        // 从任务队列中取出一个任务
        pthread_mutex_lock(&pool.mutex_queue);
        int clnt_sock = pool.queue[pool.head];
        pool.head = (pool.head + 1) % MAX_CONN;
        if((pool.tail + 1) % MAX_CONN != pool.head) {
            pthread_cond_signal(&pool.queue_not_full);
        }
        pthread_mutex_unlock(&pool.mutex_queue);
        if(pool.shutdown) {
            break;
        }
        // 处理任务
        handle_clnt(clnt_sock);
        close(clnt_sock);
    }
    return NULL;
}

int main(){
    // 创建套接字，参数说明：
    //   AF_INET: 使用 IPv4
    //   SOCK_STREAM: 面向连接的数据传输方式
    //   IPPROTO_TCP: 使用 TCP 协议
    if((serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
        print_perror("socket error!\n");

    // 将套接字和指定的 IP、端口绑定
    //   用 0 填充 serv_addr（它是一个 sockaddr_in 结构体）
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    //   设置 IPv4
    //   设置 IP 地址
    //   设置端口
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
    serv_addr.sin_port = htons(BIND_PORT);
    //   绑定
    if(bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1)
        print_perror("bind error!\n");

    // 使得 serv_sock 套接字进入监听状态，开始等待客户端发起请求
    if(listen(serv_sock, MAX_CONN) == -1)
        print_perror("listen error!\n");

    // 接收客户端请求，获得一个可以与客户端通信的新的生成的套接字 clnt_sock
    struct sockaddr_in clnt_addr;
    socklen_t clnt_addr_size = sizeof(clnt_addr);

    // 初始化线程池
    sem_init(&pool.sem_queue, 0, 0);
    pthread_mutex_init(&pool.mutex_queue, NULL);
    pthread_cond_init(&pool.queue_not_full, NULL);
    pthread_cond_init(&pool.queue_not_empty, NULL);
    pool.head = 0;
    pool.tail = 0;
    pool.clnt_cnt = 0;
    for(int i = 0;i < THREAD_POOL_SIZE;i++)
    {
        if(pthread_create(&pool.threads[i], NULL, thread_func, NULL) == -1)
            print_perror("pthread_create error!\n");
    }

    while (1) // 一直循环
    {
        // 当没有客户端连接时，accept() 会阻塞程序执行，直到有客户端连接进来
        clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
        if(clnt_sock == -1) {
            perror("accept error!\n");
            continue;
        }
        // 处理客户端的请求
        //handle_clnt(clnt_sock);
        pthread_mutex_lock(&pool.mutex_queue);
        // 线程池已满时等待
        while((pool.tail + 1) % MAX_CONN == pool.head) {
            pthread_cond_wait(&pool.queue_not_full, &pool.mutex_queue);
        }
        pool.queue[pool.tail] = clnt_sock;
        pool.clnt_socks[pool.clnt_cnt++] = clnt_sock;
        pool.tail = (pool.tail + 1) % MAX_CONN;
        if(pool.head != pool.tail) {
            pthread_cond_signal(&pool.queue_not_empty);
        }
        pthread_mutex_unlock(&pool.mutex_queue);
        sem_post(&pool.sem_queue);
    }
    
    // 实际上这里的代码不可到达，可以在 while 循环中收到 SIGINT 信号时主动 break
    // 关闭套接字
    close(serv_sock);
    return 0;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>
#include <semaphore.h>
#include <signal.h>
#include <ctype.h>
#include <sys/stat.h>
#include <errno.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 100
#define QUEUE_SIZE 40960
#define BUFFER_SIZE 4096

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"

// 线程池结构体
typedef struct thread_pool {
    pthread_t threads[THREAD_POOL_SIZE]; // 线程数组
    int queue[QUEUE_SIZE]; // 任务队列
    int head; // 任务队列的头部
    int tail; // 任务队列的尾部
    int clnt_socks[MAX_CONN]; // 存储客户端套接字的数组
    int clnt_cnt; // 连接的客户端数量
    sem_t sem_queue; // 任务队列的信号量
    pthread_mutex_t mutex_queue; // 互斥锁，用于保护任务队列的并发访问
    pthread_cond_t queue_not_full; // 条件变量，用于判断任务队列是否已满
    pthread_cond_t queue_not_empty; // 条件变量，用于判断任务队列是否为空
    int shutdown; // 表示线程池是否关闭
} thread_pool_t;

thread_pool_t pool;

int serv_sock;
int clnt_sock;

void print_perror(char *str) {
    perror(str);
    exit(1);
}

void divide_request(char *req, ssize_t req_len, char *method,char *url,char *version,char *host)
{
    ssize_t s1 = 0;
    while(s1 < req_len && req[s1] != ' ') {
        method[s1] = req[s1];
        s1++;
    }
    method[s1] = '\0';
    ssize_t s2 = s1 + 1;
    while(s2 < req_len && req[s2] != ' ') {
        url[s2 - s1 - 1] = req[s2];
        s2++;
    }
    url[s2 - s1 - 1] = '\0';
    ssize_t s3 = s2 + 1;
    while(s3 < req_len && req[s3] != '\n') {
        version[s3 - s2 - 1] = req[s3];
        s3++;
    }
    version[s3 - s2 - 1] = '\n';
    version[s3- s2] = '\0';
    ssize_t s4 = s3 + 1;
    while(s4 < req_len && req[s4] != '\n') {
        host[s4 - s3 - 1] = req[s4];
        s4++;
    }
    host[s4 - s3 - 1] = '\n';
    host[s4 - s3] = '\0';
}

// 解析 HTTP 请求
int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len, char *version)
{
    char* req = request;
    char *method = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *url = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *host = (char *)malloc(MAX_RECV_LEN * sizeof(char));
    //char *version = (char*) malloc(MAX_RECV_LEN * sizeof(char));

    divide_request(req, req_len, method, url, version, host);
    ssize_t url_len = strlen(url);
    ssize_t host_len = strlen(host);
    //ssize_t ver_len = strlen(version);
    // 如果请求的方法不为GET/请求的URL不以'/'开头/请求的版本号不为HTTP/开头或不以\r\n结尾，则返回错误
    if (strcmp(method,"GET") != 0 || url[0] != '/' ||
        (strncmp(version,"HTTP/1.0\r\n",10) != 0 && strncmp(version, "HTTP/1.1\r\n",10) != 0) ||
        strncmp(host, "Host: ", 6) != 0 || host[host_len-2] != '\r' || host[host_len-1] != '\n') {
        return -1;
    }
    memcpy(path,url,url_len+1);
    *path_len = url_len;
    return 0;
}

int get_content(char *path, long *file_size, FILE **file)
{
    char cur_dir[MAX_PATH_LEN];
    if(getcwd(cur_dir,sizeof(cur_dir)) == NULL) {
        perror("getcwd error!\n");
        return -1;
    }
    char *file_path = (char*) malloc(MAX_PATH_LEN * 2 * sizeof(char));
    if(file_path == NULL) {
        perror("malloc error!\n");
        return -1;
    }

    if(strlen(cur_dir) + strlen(path) + 2 > 2*MAX_PATH_LEN) {
        free(file_path);
        return -1;
    }
    snprintf(file_path, 2*MAX_PATH_LEN, "%s%s", cur_dir, path);

    struct stat path_stat;
    if(stat(file_path, &path_stat) == -1) {
        return -2;
    }
    if(S_ISDIR(path_stat.st_mode)) {
        fprintf(stderr, "%s is a directory!\n", file_path);
        return -1;
    }
    if(access(file_path, F_OK) == -1) {
        // 请求资源不存在时，返回-2
        perror("access error!\n");
        return -2;
    }

    // 判断访问路径是否跳出当前路径
    char *real_path = realpath(file_path, NULL);
    if(real_path == NULL) {
        perror("realpath error!\n");
        free(file_path);
        return -1;
    }
    // 检查绝对路径是否以当前目录为前缀
    if (strncmp(real_path, cur_dir, strlen(cur_dir)) != 0) {
        fprintf(stderr, "Error: Path traversal attempt detected\n");
        free(real_path);
        free(file_path);
        return -1;
    }
    
    *file = fopen(file_path, "r");
    if (*file == NULL) {
        perror("fopen error!\n");
        free(file_path);
        return -2;
    }

    fseek(*file, 0, SEEK_END);
    *file_size = ftell(*file);
    fseek(*file, 0, SEEK_SET);

    free(file_path);
    return 0;
}

int write_response(char *response, int ret, int ret_2, long file_size, int clnt_sock) 
{
    if(ret == -1 || ret_2 == -1) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_500);
    }
    else if(ret_2 == -2) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_404);
    }
    else if(ret == 0 && ret_2 == 0) {
        sprintf(response,
            "HTTP/1.0 %s\r\nContent-Length: %zd\r\n\r\n",
            HTTP_STATUS_200, file_size);
    }
    ssize_t response_len = strlen(response);

    // 写入响应，直到所有数据都被写入
    ssize_t write_len = 0;
    while(response_len > 0) {
        if((write_len = write(clnt_sock, response, response_len)) < 0) {
            perror("write error!\n");
            return -1;
        }
        response += write_len;
        response_len -= write_len;
    }
    return 0;
}

void handle_clnt(int clnt_sock)
{
    // 读取客户端发送来的数据，并解析
    char* req_buf = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char* version = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    // 构造要返回的数据
    // 注意，响应头部后需要有一个多余换行（\r\n\r\n），然后才是响应内容
    char* response = (char*) malloc(MAX_SEND_LEN * sizeof(char));
    // 根据 HTTP 请求的内容，解析资源路径和 Host 头
    char* path = (char*) malloc(MAX_PATH_LEN * sizeof(char));

    ssize_t req_len = 0;
    ssize_t n = 0;
    ssize_t max_recv_len = MAX_RECV_LEN;
    // 读取请求，直到遇到 "\r\n\r\n"
    while (1) {
        n = read(clnt_sock, req_buf + req_len, max_recv_len - req_len);
        if(n < 0) {
            if(errno == EINTR) continue;
            perror("read error!\n");
            goto end;
        }
        req_len += n;
        if(strlen(req_buf) >= 3 && strncmp(req_buf, "GET", 3) != 0) {
            write_response(response, -1, -1, 0, clnt_sock);
            goto end;
        }
        if (req_len >= 4 && strcmp(req_buf + req_len - 4, "\r\n\r\n") == 0) {
            break;
        }
        if(req_len >= max_recv_len) {
            max_recv_len *= 2;
            char *new_req_buf = (char *)realloc(req_buf, max_recv_len * sizeof(char));
            if(!new_req_buf) {
                perror("realloc error!\n");
                goto end;
            }
            req_buf = new_req_buf;
        }   
    }

    ssize_t path_len;
    int ret_1 = parse_request(req_buf, req_len, path, &path_len, version);
    long file_size;
    //char* content = NULL;
    FILE *file = NULL;
    int ret_2 = get_content(path, &file_size, &file);
    
    if(write_response(response, ret_1, ret_2, file_size, clnt_sock) == -1){
        goto end;
    }
    if(ret_2 == 0) {
        char buffer[BUFFER_SIZE];
        while (!feof(file)) {
            size_t n = fread(buffer, 1, BUFFER_SIZE, file);
            if (n < 0) {
                perror("read error!\n");
                break;
            }
            ssize_t write_len = 0;
            while (write_len < n) {
                ssize_t ret = write(clnt_sock, buffer + write_len, n - write_len);
                if (ret < 0) {
                    if(errno == EINTR) continue;
                    perror("write error!\n");
                    break;
                }
                write_len += ret;
            }
        }
        fclose(file);
    }
end:
    // 释放内存
    free(req_buf);
    free(path);
    free(response);
    free(version);
    //if(file != NULL)
      //  fclose(file);
    return;
}

void *thread_func(void* arg)
{
    while (1)
    {
        // 等待信号量
        sem_wait(&pool.sem_queue);
        // 从任务队列中取出一个任务
        pthread_mutex_lock(&pool.mutex_queue);
        int clnt_sock = pool.queue[pool.head];
        pool.head = (pool.head + 1) % MAX_CONN;
        if((pool.tail + 1) % MAX_CONN != pool.head) {
            pthread_cond_signal(&pool.queue_not_full);
        }
        pthread_mutex_unlock(&pool.mutex_queue);
        if(pool.shutdown) {
            break;
        }
        // 处理任务
        handle_clnt(clnt_sock);
        close(clnt_sock);
    }
    return NULL;
}

int main(){
    // 创建套接字，参数说明：
    //   AF_INET: 使用 IPv4
    //   SOCK_STREAM: 面向连接的数据传输方式
    //   IPPROTO_TCP: 使用 TCP 协议
    if((serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
        print_perror("socket error!\n");

    // 将套接字和指定的 IP、端口绑定
    //   用 0 填充 serv_addr（它是一个 sockaddr_in 结构体）
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    //   设置 IPv4
    //   设置 IP 地址
    //   设置端口
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
    serv_addr.sin_port = htons(BIND_PORT);
    //   绑定
    if(bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1)
        print_perror("bind error!\n");

    // 使得 serv_sock 套接字进入监听状态，开始等待客户端发起请求
    if(listen(serv_sock, MAX_CONN) == -1)
        print_perror("listen error!\n");

    // 接收客户端请求，获得一个可以与客户端通信的新的生成的套接字 clnt_sock
    struct sockaddr_in clnt_addr;
    socklen_t clnt_addr_size = sizeof(clnt_addr);

    // 初始化线程池
    sem_init(&pool.sem_queue, 0, 0);
    pthread_mutex_init(&pool.mutex_queue, NULL);
    pthread_cond_init(&pool.queue_not_full, NULL);
    pthread_cond_init(&pool.queue_not_empty, NULL);
    pool.head = 0;
    pool.tail = 0;
    pool.clnt_cnt = 0;
    for(int i = 0;i < THREAD_POOL_SIZE;i++)
    {
        if(pthread_create(&pool.threads[i], NULL, thread_func, NULL) == -1)
            print_perror("pthread_create error!\n");
    }

    while (1) // 一直循环
    {
        // 当没有客户端连接时，accept() 会阻塞程序执行，直到有客户端连接进来
        clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
        if(clnt_sock == -1) {
            perror("accept error!\n");
            continue;
        }
        // 处理客户端的请求
        //handle_clnt(clnt_sock);
        pthread_mutex_lock(&pool.mutex_queue);
        // 线程池已满时等待
        while((pool.tail + 1) % MAX_CONN == pool.head) {
            pthread_cond_wait(&pool.queue_not_full, &pool.mutex_queue);
        }
        pool.queue[pool.tail] = clnt_sock;
        pool.clnt_socks[pool.clnt_cnt++] = clnt_sock;
        pool.tail = (pool.tail + 1) % MAX_CONN;
        if(pool.head != pool.tail) {
            pthread_cond_signal(&pool.queue_not_empty);
        }
        pthread_mutex_unlock(&pool.mutex_queue);
        sem_post(&pool.sem_queue);
    }
    
    // 实际上这里的代码不可到达，可以在 while 循环中收到 SIGINT 信号时主动 break
    // 关闭套接字
    close(serv_sock);
    return 0;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>
#include <semaphore.h>
#include <signal.h>
#include <ctype.h>
#include <sys/stat.h>
#include <errno.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 100
#define QUEUE_SIZE 40960
#define BUFFER_SIZE 4096

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"

// 线程池结构体
typedef struct thread_pool {
    pthread_t threads[THREAD_POOL_SIZE]; // 线程数组
    int queue[QUEUE_SIZE]; // 任务队列
    int head; // 任务队列的头部
    int tail; // 任务队列的尾部
    int clnt_socks[MAX_CONN]; // 存储客户端套接字的数组
    int clnt_cnt; // 连接的客户端数量
    sem_t sem_queue; // 任务队列的信号量
    pthread_mutex_t mutex_queue; // 互斥锁，用于保护任务队列的并发访问
    pthread_cond_t queue_not_full; // 条件变量，用于判断任务队列是否已满
    pthread_cond_t queue_not_empty; // 条件变量，用于判断任务队列是否为空
    int shutdown; // 表示线程池是否关闭
} thread_pool_t;

thread_pool_t pool;

int serv_sock;
int clnt_sock;

void print_perror(char *str) {
    perror(str);
    exit(1);
}

void divide_request(char *req, ssize_t req_len, char *method,char *url,char *version,char *host)
{
    ssize_t s1 = 0;
    while(s1 < req_len && req[s1] != ' ') {
        method[s1] = req[s1];
        s1++;
    }
    method[s1] = '\0';
    ssize_t s2 = s1 + 1;
    while(s2 < req_len && req[s2] != ' ') {
        url[s2 - s1 - 1] = req[s2];
        s2++;
    }
    url[s2 - s1 - 1] = '\0';
    ssize_t s3 = s2 + 1;
    while(s3 < req_len && req[s3] != '\n') {
        version[s3 - s2 - 1] = req[s3];
        s3++;
    }
    version[s3 - s2 - 1] = '\n';
    version[s3- s2] = '\0';
    ssize_t s4 = s3 + 1;
    while(s4 < req_len && req[s4] != '\n') {
        host[s4 - s3 - 1] = req[s4];
        s4++;
    }
    host[s4 - s3 - 1] = '\n';
    host[s4 - s3] = '\0';
}

// 解析 HTTP 请求
int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len, char *version)
{
    char* req = request;
    char *method = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *url = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *host = (char *)malloc(MAX_RECV_LEN * sizeof(char));
    //char *version = (char*) malloc(MAX_RECV_LEN * sizeof(char));

    divide_request(req, req_len, method, url, version, host);
    ssize_t url_len = strlen(url);
    ssize_t host_len = strlen(host);
    //ssize_t ver_len = strlen(version);
    // 如果请求的方法不为GET/请求的URL不以'/'开头/请求的版本号不为HTTP/开头或不以\r\n结尾，则返回错误
    if (strcmp(method,"GET") != 0 || url[0] != '/' ||
        (strncmp(version,"HTTP/1.0\r\n",10) != 0 && strncmp(version, "HTTP/1.1\r\n",10) != 0) ||
        strncmp(host, "Host: ", 6) != 0 || host[host_len-2] != '\r' || host[host_len-1] != '\n') {
        return -1;
    }
    memcpy(path,url,url_len+1);
    *path_len = url_len;
    return 0;
}

int get_content(char *path, long *file_size, FILE **file)
{
    char cur_dir[MAX_PATH_LEN];
    if(getcwd(cur_dir,sizeof(cur_dir)) == NULL) {
        perror("getcwd error!\n");
        return -1;
    }
    char *file_path = (char*) malloc(MAX_PATH_LEN * 2 * sizeof(char));
    if(file_path == NULL) {
        perror("malloc error!\n");
        return -1;
    }

    if(strlen(cur_dir) + strlen(path) + 2 > 2*MAX_PATH_LEN) {
        free(file_path);
        return -1;
    }
    snprintf(file_path, 2*MAX_PATH_LEN, "%s%s", cur_dir, path);

    struct stat path_stat;
    if(stat(file_path, &path_stat) == -1) {
        return -2;
    }
    if(S_ISDIR(path_stat.st_mode)) {
        fprintf(stderr, "%s is a directory!\n", file_path);
        return -1;
    }
    if(access(file_path, F_OK) == -1) {
        // 请求资源不存在时，返回-2
        perror("access error!\n");
        return -2;
    }

    // 判断访问路径是否跳出当前路径
    char *real_path = realpath(file_path, NULL);
    if(real_path == NULL) {
        perror("realpath error!\n");
        free(file_path);
        return -1;
    }
    // 检查绝对路径是否以当前目录为前缀
    if (strncmp(real_path, cur_dir, strlen(cur_dir)) != 0) {
        fprintf(stderr, "Error: Path traversal attempt detected\n");
        free(real_path);
        free(file_path);
        return -1;
    }
    
    *file = fopen(file_path, "r");
    if (*file == NULL) {
        perror("fopen error!\n");
        free(file_path);
        return -2;
    }

    fseek(*file, 0, SEEK_END);
    *file_size = ftell(*file);
    fseek(*file, 0, SEEK_SET);

    free(file_path);
    return 0;
}

int write_response(char *response, int ret, int ret_2, long file_size, int clnt_sock) 
{
    if(ret == -1 || ret_2 == -1) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_500);
    }
    else if(ret_2 == -2) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_404);
    }
    else if(ret == 0 && ret_2 == 0) {
        sprintf(response,
            "HTTP/1.0 %s\r\nContent-Length: %zd\r\n\r\n",
            HTTP_STATUS_200, file_size);
    }
    ssize_t response_len = strlen(response);

    // 写入响应，直到所有数据都被写入
    ssize_t write_len = 0;
    while(response_len > 0) {
        if((write_len = write(clnt_sock, response, response_len)) < 0) {
            perror("write error!\n");
            return -1;
        }
        response += write_len;
        response_len -= write_len;
    }
    return 0;
}

void handle_clnt(int clnt_sock)
{
    // 读取客户端发送来的数据，并解析
    char* req_buf = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char* version = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    // 构造要返回的数据
    // 注意，响应头部后需要有一个多余换行（\r\n\r\n），然后才是响应内容
    char* response = (char*) malloc(MAX_SEND_LEN * sizeof(char));
    // 根据 HTTP 请求的内容，解析资源路径和 Host 头
    char* path = (char*) malloc(MAX_PATH_LEN * sizeof(char));

    ssize_t req_len = 0;
    ssize_t n = 0;
    ssize_t max_recv_len = MAX_RECV_LEN;
    // 读取请求，直到遇到 "\r\n\r\n"
    while (1) {
        n = read(clnt_sock, req_buf + req_len, max_recv_len - req_len);
        if(n < 0) {
            if(errno == EINTR) continue;
            perror("read error!\n");
            goto end;
        }
        req_len += n;
        if(strlen(req_buf) >= 3 && strncmp(req_buf, "GET", 3) != 0) {
            write_response(response, -1, -1, 0, clnt_sock);
            goto end;
        }
        if (req_len >= 4 && strcmp(req_buf + req_len - 4, "\r\n\r\n") == 0) {
            break;
        }
        if(req_len >= max_recv_len) {
            max_recv_len *= 2;
            char *new_req_buf = (char *)realloc(req_buf, max_recv_len * sizeof(char));
            if(!new_req_buf) {
                perror("realloc error!\n");
                goto end;
            }
            req_buf = new_req_buf;
        }   
    }

    ssize_t path_len;
    int ret_1 = parse_request(req_buf, req_len, path, &path_len, version);
    long file_size;
    //char* content = NULL;
    FILE *file = NULL;
    int ret_2 = get_content(path, &file_size, &file);
    
    if(write_response(response, ret_1, ret_2, file_size, clnt_sock) == -1){
        goto end;
    }
    if(ret_2 == 0) {
        char buffer[BUFFER_SIZE];
        while (!feof(file)) {
            size_t n = fread(buffer, 1, BUFFER_SIZE, file);
            if (n < 0) {
                perror("read error!\n");
                break;
            }
            ssize_t write_len = 0;
            while (write_len < n) {
                ssize_t ret = write(clnt_sock, buffer + write_len, n - write_len);
                if (ret < 0) {
                    if(errno == EINTR) continue;
                    perror("write error!\n");
                    break;
                }
                write_len += ret;
            }
        }
        fclose(file);
    }
end:
    // 释放内存
    free(req_buf);
    free(path);
    free(response);
    free(version);
    //if(file != NULL)
      //  fclose(file);
    return;
}

void *thread_func(void* arg)
{
    while (1)
    {
        // 等待信号量
        sem_wait(&pool.sem_queue);
        // 从任务队列中取出一个任务
        pthread_mutex_lock(&pool.mutex_queue);
        int clnt_sock = pool.queue[pool.head];
        pool.head = (pool.head + 1) % MAX_CONN;
        if((pool.tail + 1) % MAX_CONN != pool.head) {
            pthread_cond_signal(&pool.queue_not_full);
        }
        pthread_mutex_unlock(&pool.mutex_queue);
        if(pool.shutdown) {
            break;
        }
        // 处理任务
        handle_clnt(clnt_sock);
        close(clnt_sock);
    }
    return NULL;
}

int main(){
    // 创建套接字，参数说明：
    //   AF_INET: 使用 IPv4
    //   SOCK_STREAM: 面向连接的数据传输方式
    //   IPPROTO_TCP: 使用 TCP 协议
    if((serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
        print_perror("socket error!\n");

    // 将套接字和指定的 IP、端口绑定
    //   用 0 填充 serv_addr（它是一个 sockaddr_in 结构体）
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    //   设置 IPv4
    //   设置 IP 地址
    //   设置端口
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
    serv_addr.sin_port = htons(BIND_PORT);
    //   绑定
    if(bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1)
        print_perror("bind error!\n");

    // 使得 serv_sock 套接字进入监听状态，开始等待客户端发起请求
    if(listen(serv_sock, MAX_CONN) == -1)
        print_perror("listen error!\n");

    // 接收客户端请求，获得一个可以与客户端通信的新的生成的套接字 clnt_sock
    struct sockaddr_in clnt_addr;
    socklen_t clnt_addr_size = sizeof(clnt_addr);

    // 初始化线程池
    sem_init(&pool.sem_queue, 0, 0);
    pthread_mutex_init(&pool.mutex_queue, NULL);
    pthread_cond_init(&pool.queue_not_full, NULL);
    pthread_cond_init(&pool.queue_not_empty, NULL);
    pool.head = 0;
    pool.tail = 0;
    pool.clnt_cnt = 0;
    for(int i = 0;i < THREAD_POOL_SIZE;i++)
    {
        if(pthread_create(&pool.threads[i], NULL, thread_func, NULL) == -1)
            print_perror("pthread_create error!\n");
    }

    while (1) // 一直循环
    {
        // 当没有客户端连接时，accept() 会阻塞程序执行，直到有客户端连接进来
        clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
        if(clnt_sock == -1) {
            perror("accept error!\n");
            continue;
        }
        // 处理客户端的请求
        //handle_clnt(clnt_sock);
        pthread_mutex_lock(&pool.mutex_queue);
        // 线程池已满时等待
        while((pool.tail + 1) % MAX_CONN == pool.head) {
            pthread_cond_wait(&pool.queue_not_full, &pool.mutex_queue);
        }
        pool.queue[pool.tail] = clnt_sock;
        pool.clnt_socks[pool.clnt_cnt++] = clnt_sock;
        pool.tail = (pool.tail + 1) % MAX_CONN;
        if(pool.head != pool.tail) {
            pthread_cond_signal(&pool.queue_not_empty);
        }
        pthread_mutex_unlock(&pool.mutex_queue);
        sem_post(&pool.sem_queue);
    }
    
    // 实际上这里的代码不可到达，可以在 while 循环中收到 SIGINT 信号时主动 break
    // 关闭套接字
    close(serv_sock);
    return 0;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>
#include <semaphore.h>
#include <signal.h>
#include <ctype.h>
#include <sys/stat.h>
#include <errno.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 100
#define QUEUE_SIZE 40960
#define BUFFER_SIZE 4096

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"

// 线程池结构体
typedef struct thread_pool {
    pthread_t threads[THREAD_POOL_SIZE]; // 线程数组
    int queue[QUEUE_SIZE]; // 任务队列
    int head; // 任务队列的头部
    int tail; // 任务队列的尾部
    int clnt_socks[MAX_CONN]; // 存储客户端套接字的数组
    int clnt_cnt; // 连接的客户端数量
    sem_t sem_queue; // 任务队列的信号量
    pthread_mutex_t mutex_queue; // 互斥锁，用于保护任务队列的并发访问
    pthread_cond_t queue_not_full; // 条件变量，用于判断任务队列是否已满
    pthread_cond_t queue_not_empty; // 条件变量，用于判断任务队列是否为空
    int shutdown; // 表示线程池是否关闭
} thread_pool_t;

thread_pool_t pool;

int serv_sock;
int clnt_sock;

void print_perror(char *str) {
    perror(str);
    exit(1);
}

void divide_request(char *req, ssize_t req_len, char *method,char *url,char *version,char *host)
{
    ssize_t s1 = 0;
    while(s1 < req_len && req[s1] != ' ') {
        method[s1] = req[s1];
        s1++;
    }
    method[s1] = '\0';
    ssize_t s2 = s1 + 1;
    while(s2 < req_len && req[s2] != ' ') {
        url[s2 - s1 - 1] = req[s2];
        s2++;
    }
    url[s2 - s1 - 1] = '\0';
    ssize_t s3 = s2 + 1;
    while(s3 < req_len && req[s3] != '\n') {
        version[s3 - s2 - 1] = req[s3];
        s3++;
    }
    version[s3 - s2 - 1] = '\n';
    version[s3- s2] = '\0';
    ssize_t s4 = s3 + 1;
    while(s4 < req_len && req[s4] != '\n') {
        host[s4 - s3 - 1] = req[s4];
        s4++;
    }
    host[s4 - s3 - 1] = '\n';
    host[s4 - s3] = '\0';
}

// 解析 HTTP 请求
int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len, char *version)
{
    char* req = request;
    char *method = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *url = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char *host = (char *)malloc(MAX_RECV_LEN * sizeof(char));
    //char *version = (char*) malloc(MAX_RECV_LEN * sizeof(char));

    divide_request(req, req_len, method, url, version, host);
    ssize_t url_len = strlen(url);
    ssize_t host_len = strlen(host);
    //ssize_t ver_len = strlen(version);
    // 如果请求的方法不为GET/请求的URL不以'/'开头/请求的版本号不为HTTP/开头或不以\r\n结尾，则返回错误
    if (strcmp(method,"GET") != 0 || url[0] != '/' ||
        (strncmp(version,"HTTP/1.0\r\n",10) != 0 && strncmp(version, "HTTP/1.1\r\n",10) != 0) ||
        strncmp(host, "Host: ", 6) != 0 || host[host_len-2] != '\r' || host[host_len-1] != '\n') {
        return -1;
    }
    memcpy(path,url,url_len+1);
    *path_len = url_len;
    return 0;
}

int get_content(char *path, long *file_size, FILE **file)
{
    char cur_dir[MAX_PATH_LEN];
    if(getcwd(cur_dir,sizeof(cur_dir)) == NULL) {
        perror("getcwd error!\n");
        return -1;
    }
    char *file_path = (char*) malloc(MAX_PATH_LEN * 2 * sizeof(char));
    if(file_path == NULL) {
        perror("malloc error!\n");
        return -1;
    }

    if(strlen(cur_dir) + strlen(path) + 2 > 2*MAX_PATH_LEN) {
        free(file_path);
        return -1;
    }
    snprintf(file_path, 2*MAX_PATH_LEN, "%s%s", cur_dir, path);

    struct stat path_stat;
    if(stat(file_path, &path_stat) == -1) {
        return -2;
    }
    if(S_ISDIR(path_stat.st_mode)) {
        fprintf(stderr, "%s is a directory!\n", file_path);
        return -1;
    }
    if(access(file_path, F_OK) == -1) {
        // 请求资源不存在时，返回-2
        perror("access error!\n");
        return -2;
    }

    // 判断访问路径是否跳出当前路径
    char *real_path = realpath(file_path, NULL);
    if(real_path == NULL) {
        perror("realpath error!\n");
        free(file_path);
        return -1;
    }
    // 检查绝对路径是否以当前目录为前缀
    if (strncmp(real_path, cur_dir, strlen(cur_dir)) != 0) {
        fprintf(stderr, "Error: Path traversal attempt detected\n");
        free(real_path);
        free(file_path);
        return -1;
    }
    
    *file = fopen(file_path, "r");
    if (*file == NULL) {
        perror("fopen error!\n");
        free(file_path);
        return -2;
    }

    fseek(*file, 0, SEEK_END);
    *file_size = ftell(*file);
    fseek(*file, 0, SEEK_SET);

    free(file_path);
    return 0;
}

int write_response(char *response, int ret, int ret_2, long file_size, int clnt_sock) 
{
    if(ret == -1 || ret_2 == -1) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_500);
    }
    else if(ret_2 == -2) {
        sprintf(response,
            "HTTP/1.0 %s \r\nContent-Length: 0\r\n\r\n",
            HTTP_STATUS_404);
    }
    else if(ret == 0 && ret_2 == 0) {
        sprintf(response,
            "HTTP/1.0 %s\r\nContent-Length: %zd\r\n\r\n",
            HTTP_STATUS_200, file_size);
    }
    ssize_t response_len = strlen(response);

    // 写入响应，直到所有数据都被写入
    ssize_t write_len = 0;
    while(response_len > 0) {
        if((write_len = write(clnt_sock, response, response_len)) < 0) {
            perror("write error!\n");
            return -1;
        }
        response += write_len;
        response_len -= write_len;
    }
    return 0;
}

void handle_clnt(int clnt_sock)
{
    // 读取客户端发送来的数据，并解析
    char* req_buf = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    char* version = (char*) malloc(MAX_RECV_LEN * sizeof(char));
    // 构造要返回的数据
    // 注意，响应头部后需要有一个多余换行（\r\n\r\n），然后才是响应内容
    char* response = (char*) malloc(MAX_SEND_LEN * sizeof(char));
    // 根据 HTTP 请求的内容，解析资源路径和 Host 头
    char* path = (char*) malloc(MAX_PATH_LEN * sizeof(char));

    ssize_t req_len = 0;
    ssize_t n = 0;
    ssize_t max_recv_len = MAX_RECV_LEN;
    // 读取请求，直到遇到 "\r\n\r\n"
    while (1) {
        n = read(clnt_sock, req_buf + req_len, max_recv_len - req_len);
        if(n < 0) {
            if(errno == EINTR) continue;
            perror("read error!\n");
            goto end;
        }
        req_len += n;
        if(strlen(req_buf) >= 3 && strncmp(req_buf, "GET", 3) != 0) {
            write_response(response, -1, -1, 0, clnt_sock);
            goto end;
        }
        if (req_len >= 4 && strcmp(req_buf + req_len - 4, "\r\n\r\n") == 0) {
            break;
        }
        if(req_len >= max_recv_len) {
            max_recv_len *= 2;
            char *new_req_buf = (char *)realloc(req_buf, max_recv_len * sizeof(char));
            if(!new_req_buf) {
                perror("realloc error!\n");
                goto end;
            }
            req_buf = new_req_buf;
        }   
    }

    ssize_t path_len;
    int ret_1 = parse_request(req_buf, req_len, path, &path_len, version);
    long file_size;
    //char* content = NULL;
    FILE *file = NULL;
    int ret_2 = get_content(path, &file_size, &file);
    
    if(write_response(response, ret_1, ret_2, file_size, clnt_sock) == -1){
        goto end;
    }
    if(ret_2 == 0) {
        char buffer[BUFFER_SIZE];
        while (!feof(file)) {
            size_t n = fread(buffer, 1, BUFFER_SIZE, file);
            if (n < 0) {
                perror("read error!\n");
                break;
            }
            ssize_t write_len = 0;
            while (write_len < n) {
                ssize_t ret = write(clnt_sock, buffer + write_len, n - write_len);
                if (ret < 0) {
                    if(errno == EINTR) continue;
                    perror("write error!\n");
                    break;
                }
                write_len += ret;
            }
        }
        fclose(file);
    }
end:
    // 释放内存
    free(req_buf);
    free(path);
    free(response);
    free(version);
    //if(file != NULL)
      //  fclose(file);
    return;
}

void *thread_func(void* arg)
{
    while (1)
    {
        // 等待信号量
        sem_wait(&pool.sem_queue);
        // 从任务队列中取出一个任务
        pthread_mutex_lock(&pool.mutex_queue);
        int clnt_sock = pool.queue[pool.head];
        pool.head = (pool.head + 1) % MAX_CONN;
        if((pool.tail + 1) % MAX_CONN != pool.head) {
            pthread_cond_signal(&pool.queue_not_full);
        }
        pthread_mutex_unlock(&pool.mutex_queue);
        if(pool.shutdown) {
            break;
        }
        // 处理任务
        handle_clnt(clnt_sock);
        close(clnt_sock);
    }
    return NULL;
}

int main(){
    // 创建套接字，参数说明：
    //   AF_INET: 使用 IPv4
    //   SOCK_STREAM: 面向连接的数据传输方式
    //   IPPROTO_TCP: 使用 TCP 协议
    if((serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
        print_perror("socket error!\n");

    // 将套接字和指定的 IP、端口绑定
    //   用 0 填充 serv_addr（它是一个 sockaddr_in 结构体）
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    //   设置 IPv4
    //   设置 IP 地址
    //   设置端口
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
    serv_addr.sin_port = htons(BIND_PORT);
    //   绑定
    if(bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1)
        print_perror("bind error!\n");

    // 使得 serv_sock 套接字进入监听状态，开始等待客户端发起请求
    if(listen(serv_sock, MAX_CONN) == -1)
        print_perror("listen error!\n");

    // 接收客户端请求，获得一个可以与客户端通信的新的生成的套接字 clnt_sock
    struct sockaddr_in clnt_addr;
    socklen_t clnt_addr_size = sizeof(clnt_addr);

    // 初始化线程池
    sem_init(&pool.sem_queue, 0, 0);
    pthread_mutex_init(&pool.mutex_queue, NULL);
    pthread_cond_init(&pool.queue_not_full, NULL);
    pthread_cond_init(&pool.queue_not_empty, NULL);
    pool.head = 0;
    pool.tail = 0;
    pool.clnt_cnt = 0;
    for(int i = 0;i < THREAD_POOL_SIZE;i++)
    {
        if(pthread_create(&pool.threads[i], NULL, thread_func, NULL) == -1)
            print_perror("pthread_create error!\n");
    }

    while (1) // 一直循环
    {
        // 当没有客户端连接时，accept() 会阻塞程序执行，直到有客户端连接进来
        clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
        if(clnt_sock == -1) {
            perror("accept error!\n");
            continue;
        }
        // 处理客户端的请求
        //handle_clnt(clnt_sock);
        pthread_mutex_lock(&pool.mutex_queue);
        // 线程池已满时等待
        while((pool.tail + 1) % MAX_CONN == pool.head) {
            pthread_cond_wait(&pool.queue_not_full, &pool.mutex_queue);
        }
        pool.queue[pool.tail] = clnt_sock;
        pool.clnt_socks[pool.clnt_cnt++] = clnt_sock;
        pool.tail = (pool.tail + 1) % MAX_CONN;
        if(pool.head != pool.tail) {
            pthread_cond_signal(&pool.queue_not_empty);
        }
        pthread_mutex_unlock(&pool.mutex_queue);
        sem_post(&pool.sem_queue);
    }
    
    // 实际上这里的代码不可到达，可以在 while 循环中收到 SIGINT 信号时主动 break
    // 关闭套接字
    close(serv_sock);
    return 0;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}
// server.c
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <functional>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <system_error>
#include <signal.h>

#define BIND_IP_ADDR "127.0.0.1"
#define BIND_PORT 8000
#define MAX_RECV_LEN 1048576
#define MAX_SEND_LEN 1048576
#define MAX_PATH_LEN 1024
#define MAX_HOST_LEN 1024
#define MAX_CONN 1024
#define THREAD_POOL_SIZE 16
#define BUFFER_SIZE 4096
#define MAX_CACHE_SIZE 100
#define MAX_CACHE_AGE 300
#define MAX_RETRIES 3
#define SOCKET_TIMEOUT_SEC 30

#define HTTP_STATUS_200 "200 OK"
#define HTTP_STATUS_404 "404 Not Found"
#define HTTP_STATUS_500 "500 Internal Server Error"
#define HTTP_STATUS_503 "503 Service Unavailable"

// 日志宏
#define LOG_ERROR(msg) std::cerr << "[ERROR] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_WARNING(msg) std::cerr << "[WARNING] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#define LOG_INFO(msg) std::cout << "[INFO] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl

// 缓存项结构
struct CacheItem {
    std::vector<char> content;
    std::string mime_type;
    size_t content_length;
    time_t last_modified;
    time_t last_accessed;
};

// 缓存类
class Cache {
private:
    std::unordered_map<std::string, CacheItem> cache_map;
    std::mutex cache_mutex;
    size_t max_items;
    time_t max_age;
    size_t hits = 0;
    size_t misses = 0;

public:
    Cache(size_t max_items = MAX_CACHE_SIZE, time_t max_age = MAX_CACHE_AGE) 
        : max_items(max_items), max_age(max_age) {
        LOG_INFO("Cache initialized with capacity " << max_items << " and max age " << max_age << "s");
    }

    bool contains(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) return false;
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                return false;
            }
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache contains failed: " << e.what());
            return false;
        }
    }

    bool get(const std::string& path, CacheItem& out_item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            auto it = cache_map.find(path);
            if (it == cache_map.end()) {
                misses++;
                return false;
            }
            
            time_t now = std::time(nullptr);
            if (now - it->second.last_accessed > max_age) {
                cache_map.erase(it);
                misses++;
                return false;
            }
            
            it->second.last_accessed = now;
            out_item = it->second;
            hits++;
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache get failed: " << e.what());
            misses++;
            return false;
        }
    }

    bool set(const std::string& path, const CacheItem& item) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            if (cache_map.size() >= max_items) {
                auto oldest = cache_map.begin();
                for (auto it = cache_map.begin(); it != cache_map.end(); ++it) {
                    if (it->second.last_accessed < oldest->second.last_accessed) {
                        oldest = it;
                    }
                }
                cache_map.erase(oldest);
                LOG_INFO("Cache full, removed oldest item");
            }
            
            cache_map[path] = item;
            cache_map[path].last_accessed = std::time(nullptr);
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache set failed: " << e.what());
            return false;
        }
    }

    void remove(const std::string& path) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.erase(path);
        } catch (const std::exception& e) {
            LOG_ERROR("Cache remove failed: " << e.what());
        }
    }

    void clear() {
        std::lock_guard<std::mutex> lock(cache_mutex);
        try {
            cache_map.clear();
            hits = 0;
            misses = 0;
        } catch (const std::exception& e) {
            LOG_ERROR("Cache clear failed: " << e.what());
        }
    }

    void get_stats(size_t& hit_count, size_t& miss_count) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        hit_count = hits;
        miss_count = misses;
    }
};

// 全局缓存对象
Cache file_cache;

// 线程池类
class ThreadPool {
public:
    explicit ThreadPool(std::size_t size, std::size_t max_queue_size)
        : max_queue_size_(max_queue_size) {
        try {
            for (std::size_t i = 0; i < size; ++i) {
                workers_.emplace_back([this] {
                    while (true) {
                        std::function<void()> task;
                        {
                            std::unique_lock<std::mutex> lock(queue_mutex_);
                            condition_.wait(lock, [this] { 
                                return !tasks_.empty() || shutdown_; 
                            });
                            if (shutdown_ && tasks_.empty()) {
                                return;
                            }
                            task = std::move(tasks_.front());
                            tasks_.pop();
                        }
                        try {
                            task();
                        } catch (const std::exception& e) {
                            LOG_ERROR("Thread pool task failed: " << e.what());
                        }
                    }
                });
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Thread pool initialization failed: " << e.what());
            throw;
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            shutdown_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    template<class F>
    bool Enqueue(F f) {
        try {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (shutdown_) {
                LOG_WARNING("Enqueue on shutdown thread pool");
                return false;
            }
            if (tasks_.size() >= max_queue_size_) {
                LOG_WARNING("Thread pool queue full");
                return false;
            }
            tasks_.emplace(std::forward<F>(f));
            condition_.notify_one();
            return true;
        } catch (const std::exception& e) {
            LOG_ERROR("Enqueue failed: " << e.what());
            return false;
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool shutdown_ = false;
    std::size_t max_queue_size_;
};

// 设置socket超时
bool set_socket_timeout(int sockfd, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket recv timeout: " << strerror(errno));
        return false;
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {
        LOG_ERROR("Failed to set socket send timeout: " << strerror(errno));
        return false;
    }
    
    return true;
}

ssize_t read_all(int fd, char** buf, size_t* max_len) {
    if (!buf || !max_len) {
        LOG_ERROR("Invalid arguments to read_all");
        return -1;
    }

    size_t initial_size = *max_len;
    if (initial_size == 0) {
        LOG_ERROR("Initial buffer size is zero");
        return -1;
    }

    size_t total_read = 0;
    size_t capacity = initial_size;
    char* temp_buf = nullptr;

    try {
        temp_buf = (char*)malloc(capacity * sizeof(char));
        if (!temp_buf) {
            LOG_ERROR("Memory allocation failed in read_all");
            return -1;
        }

        int retries = 0;
        while (retries < MAX_RETRIES) {
            if (total_read + 1 >= capacity) {
                capacity *= 2;
                char* new_buf = (char*)realloc(temp_buf, capacity * sizeof(char));
                if (!new_buf) {
                    LOG_ERROR("Memory reallocation failed in read_all");
                    free(temp_buf);
                    return -1;
                }
                temp_buf = new_buf;
            }

            ssize_t n = read(fd, temp_buf + total_read, capacity - total_read - 1);
            if (n < 0) {
                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                    retries++;
                    continue;
                }
                LOG_ERROR("Read failed: " << strerror(errno));
                free(temp_buf);
                return -1;
            } else if (n == 0) {
                break; // EOF
            }

            total_read += n;
            retries = 0;

            if (total_read >= 4 && memcmp(temp_buf + total_read - 4, "\r\n\r\n", 4) == 0) {
                break;
            }
        }

        if (retries >= MAX_RETRIES) {
            LOG_ERROR("Max read retries exceeded");
            free(temp_buf);
            return -1;
        }

        temp_buf[total_read] = '\0';
        *buf = strdup(temp_buf);
        free(temp_buf);
        
        if (!*buf) {
            LOG_ERROR("strdup failed in read_all");
            return -1;
        }

        return total_read;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_all: " << e.what());
        if (temp_buf) free(temp_buf);
        return -1;
    }
}

ssize_t write_all(int fd, const char* buf, size_t len) {
    if (!buf && len > 0) {
        LOG_ERROR("Invalid arguments to write_all");
        return -1;
    }

    ssize_t total_written = 0;
    int retries = 0;

    while (total_written < len && retries < MAX_RETRIES) {
        ssize_t n = write(fd, buf + total_written, len - total_written);
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                continue;
            }
            LOG_ERROR("Write failed: " << strerror(errno));
            return -1;
        }
        total_written += n;
        retries = 0;
    }

    if (retries >= MAX_RETRIES) {
        LOG_ERROR("Max write retries exceeded");
        return -1;
    }

    return total_written;
}

ssize_t send_response(int clnt_sock, const char* response, size_t response_len, const std::vector<char>& content) {
    if (!response) {
        LOG_ERROR("Invalid response pointer");
        return -1;
    }

    ssize_t sent_len = write_all(clnt_sock, response, response_len);
    if (sent_len < 0) {
        LOG_ERROR("Failed to send response headers");
        return -1;
    }

    if (!content.empty()) {
        sent_len = write_all(clnt_sock, content.data(), content.size());
        if (sent_len < 0) {
            LOG_ERROR("Failed to send response content");
            return -1;
        }
    }
    
    return 0;
}

int parse_request(char* request, ssize_t req_len, char* path, ssize_t* path_len) {
    if (!request || !path || !path_len || req_len <= 0) {
        LOG_ERROR("Invalid arguments to parse_request");
        return -1;
    }

    char* req = request;
    int result = -1;

    try {
        // 解析方法
        ssize_t s1 = 0;
        while (s1 < req_len && req[s1] != ' ') s1++;
        if (s1 >= req_len) {
            LOG_ERROR("Invalid request: no method");
            return -1;
        }

        char* method = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!method) {
            LOG_ERROR("Memory allocation failed for method");
            return -1;
        }
        
        memcpy(method, req, s1 * sizeof(char));
        method[s1] = '\0';
        
        if (strcmp(method, "GET") != 0) {
            free(method);
            LOG_ERROR("Unsupported HTTP method: " << method);
            return -1;
        }
        free(method);
        
        // 解析路径
        ssize_t s2 = s1 + 1;
        while (s2 < req_len && req[s2] != ' ') s2++;
        if (s2 >= req_len) {
            LOG_ERROR("Invalid request: no path");
            return -1;
        }

        memcpy(path, req + s1 + 1, (s2 - s1 - 1) * sizeof(char));
        path[s2 - s1 - 1] = '\0';
        *path_len = (s2 - s1 - 1);
        
        if (path[0] != '/') {
            LOG_ERROR("Invalid path: " << path);
            return -1;
        }

        // 解析版本
        ssize_t s3 = s2 + 1;
        while (s3 < req_len && req[s3] != '\n') s3++;
        if (s3 >= req_len) {
            LOG_ERROR("Invalid request: no version");
            return -1;
        }

        char* version = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!version) {
            LOG_ERROR("Memory allocation failed for version");
            return -1;
        }
        
        memcpy(version, req + s2 + 1, (s3 - s2 - 1) * sizeof(char));
        version[s3 - s2 - 1] = '\0';
        
        if ((strcmp(version, "HTTP/1.0\r") != 0) && (strcmp(version, "HTTP/1.1\r") != 0)) {
            free(version);
            LOG_ERROR("Unsupported HTTP version: " << version);
            return -1;
        }
        free(version);

        // 解析Host头
        ssize_t s4 = s3 + 1;
        while (s4 < req_len && req[s4] != ' ') s4++;
        if (s4 >= req_len) {
            LOG_ERROR("Invalid request: no host header");
            return -1;
        }

        char* host_head = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_head) {
            LOG_ERROR("Memory allocation failed for host_head");
            return -1;
        }
        
        memcpy(host_head, req + s3 + 1, (s4 - s3 - 1) * sizeof(char));
        host_head[s4 - s3 - 1] = '\0';
        
        if (strcmp(host_head, "Host:") != 0) {
            free(host_head);
            LOG_ERROR("Invalid host header: " << host_head);
            return -1;
        }
        free(host_head);
        
        // 解析IP
        ssize_t s5 = s4 + 1;
        while (s5 < req_len && req[s5] != ':') s5++;
        if (s5 >= req_len) {
            LOG_ERROR("Invalid request: no IP in host");
            return -1;
        }

        if (s5 == s4 + 1) {
            LOG_ERROR("Empty IP in host");
            return -1;
        }

        char* host_ip = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_ip) {
            LOG_ERROR("Memory allocation failed for host_ip");
            return -1;
        }
        
        memcpy(host_ip, req + s4 + 1, (s5 - s4 - 1) * sizeof(char));
        host_ip[s5 - s4 - 1] = '\0';
        
        if (INADDR_NONE == inet_addr(host_ip)) {
            free(host_ip);
            LOG_ERROR("Invalid IP address: " << host_ip);
            return -1;
        }
        free(host_ip);

        // 解析端口
        ssize_t s6 = s5 + 1;
        while (s6 < req_len && req[s6] != '\n') s6++;
        if (s6 >= req_len) {
            LOG_ERROR("Invalid request: no port in host");
            return -1;
        }

        if (s6 == s5 + 2) {
            LOG_ERROR("Empty port in host");
            return -1;
        }

        char* host_port = (char*)malloc(MAX_PATH_LEN * sizeof(char));
        if (!host_port) {
            LOG_ERROR("Memory allocation failed for host_port");
            return -1;
        }
        
        memcpy(host_port, req + s5 + 1, (s6 - s5 - 1) * sizeof(char));
        if (host_port[s6 - s5 - 2] != '\r') {
            free(host_port);
            LOG_ERROR("Invalid port format");
            return -1;
        }
        host_port[s6 - s5 - 2] = '\0';
        
        char* endptr;
        long port = strtol(host_port, &endptr, 10);
        if (*endptr != '\0' || port > 65535 || port < 0) {
            free(host_port);
            LOG_ERROR("Invalid port number: " << host_port);
            return -1;
        }
        free(host_port);
        
        result = 0;
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in parse_request: " << e.what());
        result = -1;
    }

    return result;
}

std::string get_mime_type(const std::string& path) {
    try {
        size_t dot_pos = path.find_last_of('.');
        if (dot_pos == std::string::npos) {
            return "application/octet-stream";
        }
        
        std::string ext = path.substr(dot_pos + 1);
        if (ext == "html" || ext == "htm") return "text/html";
        if (ext == "txt") return "text/plain";
        if (ext == "css") return "text/css";
        if (ext == "js") return "application/javascript";
        if (ext == "json") return "application/json";
        if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
        if (ext == "png") return "image/png";
        if (ext == "gif") return "image/gif";
        if (ext == "ico") return "image/x-icon";
        if (ext == "pdf") return "application/pdf";
        
        return "application/octet-stream";
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in get_mime_type: " << e.what());
        return "application/octet-stream";
    }
}

int read_file(const char *path, CacheItem& cache_item) {
    if (!path) {
        LOG_ERROR("Invalid path in read_file");
        return -1;
    }

    char work_dir[MAX_PATH_LEN] = {0};
    if (!getcwd(work_dir, sizeof(work_dir))) {
        LOG_ERROR("Failed to get current working directory: " << strerror(errno));
        return -1;
    }

    char *file_path = nullptr;
    char *real_path = nullptr;
    FILE* file = nullptr;
    int result = -1;

    try {
        file_path = (char*)malloc(MAX_PATH_LEN * 2 * sizeof(char));
        if (!file_path) {
            LOG_ERROR("Memory allocation failed for file_path");
            return -1;
        }

        snprintf(file_path, MAX_PATH_LEN * 2, "%s%s", work_dir, path);
        
        struct stat path_stat;
        if (stat(file_path, &path_stat) == -1) {
            LOG_ERROR("stat failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (access(file_path, F_OK) == -1) {
            LOG_ERROR("File not accessible: " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            LOG_ERROR("Path is a directory: " << file_path);
            result = -2;
            goto cleanup;
        }
        
        real_path = realpath(file_path, NULL);
        if (!real_path) {
            LOG_ERROR("realpath failed for " << file_path << ": " << strerror(errno));
            result = -2;//
            goto cleanup;
        }
        
        if (strncmp(real_path, work_dir, strlen(work_dir)) != 0) {
            LOG_ERROR("Path traversal attempt detected: " << real_path);
            result = -2;
            goto cleanup;
        }

        file = fopen(file_path, "rb");
        if (!file) {
            LOG_ERROR("Failed to open file " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_END) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        long file_size = ftello(file);
        if (file_size == -1) {
            LOG_ERROR("ftello failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        if (fseeko(file, 0, SEEK_SET) != 0) {
            LOG_ERROR("fseeko failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        try {
            cache_item.content.resize(file_size);
        } catch (const std::bad_alloc&) {
            LOG_ERROR("Memory allocation failed for file content");
            result = -1;
            goto cleanup;
        }

        if (fread(cache_item.content.data(), 1, file_size, file) != static_cast<size_t>(file_size)) {
            LOG_ERROR("fread failed for " << file_path << ": " << strerror(errno));
            result = -1;
            goto cleanup;
        }

        cache_item.mime_type = get_mime_type(path);
        cache_item.content_length = file_size;
        cache_item.last_modified = path_stat.st_mtime;
        cache_item.last_accessed = std::time(nullptr);

        result = 0;

    } catch (const std::exception& e) {
        LOG_ERROR("Exception in read_file: " << e.what());
        result = -1;
    }

cleanup:
    if (file) fclose(file);
    if (file_path) free(file_path);
    if (real_path) free(real_path);
    
    return result;
}

void safe_close_socket(int& sock) {
    if (sock != -1) {
        shutdown(sock, SHUT_RDWR);
        close(sock);
        sock = -1;
    }
}

void handle_clnt(int clnt_sock) {
    if (clnt_sock < 0) {
        LOG_ERROR("Invalid client socket in handle_clnt");
        return;
    }

    if (!set_socket_timeout(clnt_sock, SOCKET_TIMEOUT_SEC)) {
        LOG_ERROR("Failed to set socket timeout");
        safe_close_socket(clnt_sock);
        return;
    }

    char* req_buf = nullptr;
    size_t max_len = MAX_RECV_LEN;
    ssize_t req_len = read_all(clnt_sock, &req_buf, &max_len);
    
    if (req_len <= 0) {
        LOG_ERROR("Failed to read request or connection closed");
        if (req_buf) free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    char* path = (char*)malloc(MAX_PATH_LEN * sizeof(char));
    if (!path) {
        LOG_ERROR("Memory allocation failed for path");
        free(req_buf);
        safe_close_socket(clnt_sock);
        return;
    }

    ssize_t path_len;
    int ret_parse = parse_request(req_buf, req_len, path, &path_len);
    free(req_buf);
    
    if (ret_parse != 0) {
        LOG_ERROR("Failed to parse request");
        char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
        if (response) {
            snprintf(response, MAX_SEND_LEN, 
                    "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
            size_t response_len = strlen(response);
            write_all(clnt_sock, response, response_len);
            free(response);
        }
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    bool from_cache = false;
    CacheItem cache_item;
    std::string path_str(path);
    
    if (file_cache.contains(path_str)) {
        from_cache = file_cache.get(path_str, cache_item);
    }

    if (!from_cache) {
        int ret_readfile = read_file(path, cache_item);
        
        if (ret_readfile == -1) {
            LOG_ERROR("File not found: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_404);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (ret_readfile == -2) {
            LOG_ERROR("Invalid file access: " << path);
            char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
            if (response) {
                snprintf(response, MAX_SEND_LEN, 
                        "HTTP/1.0 %s\r\nContent-Length: 0\r\n\r\n", HTTP_STATUS_500);
                size_t response_len = strlen(response);
                write_all(clnt_sock, response, response_len);
                free(response);
            }
            free(path);
            safe_close_socket(clnt_sock);
            return;
        }
        
        if (!file_cache.set(path_str, cache_item)) {
            LOG_WARNING("Failed to cache file: " << path);
        }
    }

    char* response = (char*)malloc(MAX_SEND_LEN * sizeof(char));
    if (!response) {
        LOG_ERROR("Memory allocation failed for response");
        free(path);
        safe_close_socket(clnt_sock);
        return;
    }

    struct tm* tm_info = gmtime(&cache_item.last_modified);
    char time_buf[50];
    strftime(time_buf, sizeof(time_buf), "%a, %d %b %Y %H:%M:%S GMT", tm_info);

    snprintf(response, MAX_SEND_LEN,
            "HTTP/1.0 %s\r\n"
            "Content-Type: %s\r\n"
            "Content-Length: %zu\r\n"
            "Cache-Control: max-age=%d\r\n"
            "Last-Modified: %s\r\n\r\n",
            HTTP_STATUS_200,
            cache_item.mime_type.c_str(),
            cache_item.content_length,
            MAX_CACHE_AGE,
            time_buf);
    
    size_t response_len = strlen(response);

    if (send_response(clnt_sock, response, response_len, cache_item.content) < 0) {
        LOG_ERROR("Failed to send response");
    }

    free(response);
    free(path);
    safe_close_socket(clnt_sock);
}

volatile sig_atomic_t shutdown_flag = 0;

void signal_handler(int sig) {
    LOG_INFO("Received signal " << sig << ", shutting down...");
    shutdown_flag = 1;
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    
    // Ignore SIGPIPE to prevent crashes on socket write errors
    sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, NULL);
}

int main() {
    setup_signal_handlers();
    
    int serv_sock = -1;
    try {
        serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serv_sock < 0) {
            LOG_ERROR("Failed to create socket: " << strerror(errno));
            return EXIT_FAILURE;
        }

        // 设置SO_REUSEADDR以避免"Address already in use"错误
        int optval = 1;
        if (setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
            LOG_ERROR("Failed to set SO_REUSEADDR: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(BIND_IP_ADDR);
        if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
            LOG_ERROR("Invalid IP address: " << BIND_IP_ADDR);
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }
        serv_addr.sin_port = htons(BIND_PORT);

        if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            LOG_ERROR("Failed to bind socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        if (listen(serv_sock, MAX_CONN) < 0) {
            LOG_ERROR("Failed to listen on socket: " << strerror(errno));
            safe_close_socket(serv_sock);
            return EXIT_FAILURE;
        }

        LOG_INFO("Server started on " << BIND_IP_ADDR << ":" << BIND_PORT);

        ThreadPool pool(THREAD_POOL_SIZE, MAX_CONN);
        struct sockaddr_in clnt_addr;
        socklen_t clnt_addr_size = sizeof(clnt_addr);

        while (!shutdown_flag) {
            int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
            if (clnt_sock < 0) {
                if (errno == EINTR) {
                    continue; // 被信号中断，继续等待
                }
                LOG_ERROR("Failed to accept connection: " << strerror(errno));
                continue;
            }

            if (!pool.Enqueue([clnt_sock] { handle_clnt(clnt_sock); })) {
                LOG_ERROR("Failed to enqueue task, closing connection");
                safe_close_socket(clnt_sock);
                
                // 发送503服务不可用响应
                const char* response = "HTTP/1.0 503 Service Unavailable\r\n"
                                      "Content-Length: 0\r\n\r\n";
                write_all(clnt_sock, response, strlen(response));
                safe_close_socket(clnt_sock);
            }
        }

        LOG_INFO("Shutting down server...");
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error in main: " << e.what());
    }

    safe_close_socket(serv_sock);
    return EXIT_SUCCESS;
}